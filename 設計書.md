# RewindPM 設計方針書

## プロジェクト概要

**目的:** CQRSとイベントソーシングを活用した、過去の状態を追跡できるプロジェクト管理ツール

**技術スタック:**
- .NET 10 / C# 13
- CQRS（MediatR v12 - MITライセンス）
- Event Sourcing（自前実装）
- Blazor Server
- Entity Framework Core
- SQLite
- xUnit

---

## アーキテクチャ設計

### レイヤー構造（CQRS対応）

```
┌─────────────────────────────────────────────────────────┐
│ Presentation Layer (RewindPM.Web)                      │
│ - Blazor Server                                         │
│ - UI Components                                         │
│ - User Interaction                                      │
└─────────────────────────────────────────────────────────┘
                    ↓                    ↓
    ┌───────────────────────┐   ┌───────────────────────┐
    │ Application.Write     │   │ Application.Read      │
    │ - Commands            │   │ - Queries             │
    │ - CommandHandlers     │   │ - QueryHandlers       │
    │ - Validation          │   │ - DTOs                │
    └───────────────────────┘   └───────────────────────┘
                    ↓                    ↓
    ┌───────────────────────────────────────────────────┐
    │ Domain Layer (RewindPM.Domain)                    │
    │ - Aggregates                                       │
    │ - Domain Events                                    │
    │ - Value Objects                                    │
    │ - Business Logic                                   │
    └───────────────────────────────────────────────────┘
                    ↓                    ↓
    ┌───────────────────────┐   ┌───────────────────────┐
    │ Infrastructure.Write  │   │ Infrastructure.Read   │
    │ - Event Store         │   │ - Read Model DB       │
    │ - Event Serializer    │   │ - Query実装           │
    │ - Repository          │   │ - EF Core DbContext   │
    └───────────────────────┘   └───────────────────────┘
                    ↓                    ↑
                    └──────────┬─────────┘
                               ↓
                    ┌───────────────────────┐
                    │ Projection Layer      │
                    │ - Event Handlers      │
                    │ - Domain Event購読    │
                    │ - Read Model更新      │
                    └───────────────────────┘
```

### プロジェクト構成

**コアプロジェクト:**
- `RewindPM.Domain` - ドメイン層（Aggregate、Value Object、Domain Event）
- `RewindPM.Application.Write` - Command、CommandHandler
- `RewindPM.Application.Read` - Query、QueryHandler、Read Model DTO
- `RewindPM.Infrastructure.Write` - Event Store実装、Repository
- `RewindPM.Infrastructure.Read` - Read Model DB、Query実装
- `RewindPM.Projection` - Domain EventをRead DBに反映
- `RewindPM.Web` - Blazor UI

**テストプロジェクト:**
- `RewindPM.Domain.Test`
- `RewindPM.Application.Write.Test`
- `RewindPM.Application.Read.Test`
- `RewindPM.Infrastructure.Write.Test`
- `RewindPM.Infrastructure.Read.Test`
- `RewindPM.Projection.Test`
- `RewindPM.Web.Test`
```

### 依存関係のルール

**✅ 許可される依存:**
```
Presentation → Application.Write → Domain
Presentation → Application.Read → Domain
Infrastructure.Write → Application.Write → Domain
Infrastructure.Read → Application.Read → Domain
Projection → Domain
Projection → Infrastructure.Read
```

**❌ 禁止される依存:**
```
Domain → Application
Domain → Infrastructure
Domain → Projection
Application → Presentation
Application.Write → Application.Read（完全に分離）
Application.Read → Application.Write（完全に分離）
Infrastructure.Read → Infrastructure.Write（完全に分離）
```

**重要:** Write側とRead側は完全に分離され、相互に依存しません。データの流れはProjection層を通じて一方向のみです。

---

## CQRS実装方針

### コマンド（書き込み）

**原則:**
- 全てのコマンドはMediatRの`IRequest<TResponse>`を実装
- コマンドはイミュータブル（`record`で定義）
- **操作者情報を必ず含める**（イベントソーシングで重要）

**例:**
```csharp
public record CreateTaskCommand(
    Guid ProjectId,
    string Title,
    string Description,
    string CreatedBy
) : IRequest<Guid>;
```

### クエリ（読み取り）

**原則:**
- ReadModelから直接読み取る（パフォーマンス重視）
- タイムトラベルクエリはイベントリプレイで実現
- DTOで結果を返す

**例:**
```csharp
public record GetTaskAtTimeQuery(
    Guid TaskId,
    DateTime PointInTime
) : IRequest<TaskDto?>;
```

### コマンドとクエリの分離

```
書き込み（Command）→ Event Store → Domain Events
                                      ↓
読み取り（Query）  ← Read Model  ← Event Handlers
```

---

## イベントソーシング設計

### イベント設計原則

**1. イベントはイミュータブル**
```csharp
public abstract record DomainEvent : IDomainEvent
{
    public Guid EventId { get; init; } = Guid.NewGuid();
    public Guid AggregateId { get; init; }
    public DateTime OccurredAt { get; init; } = DateTime.UtcNow;
    public string EventType => GetType().Name;
}
```

**2. イベント名は過去形**
```csharp
// ✅ 良い例
TaskCreated, TaskStatusChanged, TaskCompleted

// ❌ 悪い例
CreateTask, ChangeTaskStatus, CompleteTask
```

**3. イベントは事実のみを記録**
```csharp
// ✅ 良い例
public record TaskStatusChanged(
    Guid TaskId,
    TaskStatus OldStatus,
    TaskStatus NewStatus,
    string ChangedBy
);

// ❌ 悪い例：計算結果や派生情報は含めない
```

### Event Storeの責務

**実装方針:**
- SQLiteで永続化
- イベントの追加のみ（更新・削除なし）
- 時系列順での取得
- 特定時点までのイベント取得（タイムトラベル用）

**インターフェース:**
```csharp
public interface IEventStore
{
    Task SaveEventsAsync(Guid aggregateId, IEnumerable<IDomainEvent> events, int expectedVersion);
    Task<List<IDomainEvent>> GetEventsAsync(Guid aggregateId);
    Task<List<IDomainEvent>> GetEventsUntilAsync(Guid aggregateId, DateTime pointInTime);
    Task<List<IDomainEvent>> GetEventsByTypeAsync(string eventType, DateTime? from, DateTime? to);
}
```

### Aggregateの再構築

**原則:**
- イベントリプレイでAggregateを復元
- Aggregateはステートレス（イベントから状態を導出）
- 未コミットイベントは分離管理

**イベント適用パターン:**
```csharp
// イベント適用パターン
protected override void When(IDomainEvent @event)
{
    switch (@event)
    {
        case TaskCreated e:
            Id = e.AggregateId;
            Title = e.Title;
            Status = TaskStatus.Todo;
            break;
        case TaskStatusChanged e:
            Status = e.NewStatus;
            break;
    }
}
```

---

## ドメイン駆動設計（DDD）

### Aggregateの設計

**原則:**
- 1つのAggregateは1つのトランザクション境界
- Aggregate間は直接参照せず、IDで参照
- ビジネスルールはAggregate内で完結

**主要Aggregate（初期実装）:**
```
ProjectAggregate
├─ ProjectId
├─ Title
└─ Description

TaskAggregate
├─ TaskId
├─ ProjectId (参照)
├─ Title, Description
├─ Status
├─ ScheduledPeriod (Value Object)
└─ ActualPeriod (Value Object)
```

**注意:** Status、Members、Priority、Dependenciesは将来実装

### Value Object

**原則:**
- イミュータブル
- 等価性は値で判断
- バリデーションロジックを内包

**例:**
```csharp
public record ScheduledPeriod
{
    public DateTime StartDate { get; init; }
    public DateTime EndDate { get; init; }
    public int EstimatedHours { get; init; }

    public ScheduledPeriod(DateTime startDate, DateTime endDate, int estimatedHours)
    {
        if (endDate <= startDate)
            throw new ArgumentException("終了日は開始日より後でなければなりません");
        
        if (estimatedHours <= 0)
            throw new ArgumentException("見積工数は正の数でなければなりません");

        StartDate = startDate;
        EndDate = endDate;
        EstimatedHours = estimatedHours;
    }
}
```

### Domain Exception

**原則:**
- ドメインの不変条件違反時にスロー
- Application層のバリデーションが正しければ発生しない
- 発生したらバリデーション漏れの可能性

**使用例:**
```csharp
public void Complete(string userId, int actualHours)
{
    // 最後の防衛ライン
    if (Status == TaskStatus.Done)
        throw new DomainException("既に完了しています");

    ApplyEvent(new TaskCompleted(Id, userId, DateTime.UtcNow, actualHours));
}
```

---

## バリデーション戦略

### 3層のバリデーション

```
┌─────────────────────────────────────┐
│ UI Layer (Blazor)                   │
│ - 入力フォーマットチェック          │
│ - 必須項目チェック                  │
│ - クライアント側の即時フィードバック│
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ Application Layer (FluentValidation)│
│ - 全ビジネスルールのチェック        │
│ - DBアクセスを伴うバリデーション    │
│ - 99%のエラーをここでキャッチ       │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ Domain Layer (Guard Clauses)        │
│ - 不変条件の保護                    │
│ - 最後の防衛ライン                  │
│ - 到達すること自体が異常            │
└─────────────────────────────────────┘
```

### FluentValidation実装原則

**1. 1コマンド1バリデーター**
```csharp
public class CreateTaskCommandValidator : AbstractValidator<CreateTaskCommand>
{
    public CreateTaskCommandValidator()
    {
        RuleFor(x => x.Title)
            .NotEmpty()
            .MaximumLength(200);
    }
}
```

**2. 非同期バリデーションの活用**
```csharp
RuleFor(x => x.TaskId)
    .MustAsync(async (taskId, _) => await IsNotCompleted(taskId))
    .WithMessage("このタスクは既に完了しています");
```

**3. MediatRパイプラインで自動実行**
```csharp
builder.Services.AddMediatR(cfg =>
{
    cfg.RegisterServicesFromAssembly(typeof(CreateTaskCommand).Assembly);
    cfg.AddOpenBehavior(typeof(ValidationBehavior<,>));
});
```

---

## タイムトラベル機能の実装方針

### コア設計

**原則:**
- イベントの時刻フィルタリングで実現
- ReadModelは現在の状態のみ保持
- 過去の状態はオンデマンドで再構築

**実装パターン:**
```csharp
// 過去の時点の状態取得
public async Task<TaskDto?> GetTaskAtTime(Guid taskId, DateTime pointInTime)
{
    // その時点までのイベントを取得
    var events = await _eventStore.GetEventsUntilAsync(taskId, pointInTime);
    
    if (!events.Any()) return null;
    
    // Aggregateを再構築
    var task = new TaskAggregate();
    task.ReplayEvents(events);
    
    // DTOに変換
    return MapToDto(task);
}
```

### UI表示方針

**過去表示時のルール:**
- **タスクの状態データ:** その時点の状態を表示
  - ステータス
  - 予定日時、実績日時
  - タスク説明（その時点の内容）
- **編集制限:** 過去表示中は全ての編集を無効化
- **表示粒度:** 日単位（同じ日の最後の状態のみ表示）

**注意:** コメント・変更履歴機能、担当者、依存関係は将来実装

### パフォーマンス考慮

**最適化戦略:**
- 頻繁にアクセスされる時点はキャッシュ
- イベント数が多い場合はスナップショット（将来実装）
- ReadModelは最新状態のみで高速化
---

## データベース設計

### Event Store（書き込み用）

```sql
Events テーブル
├─ EventId (PK)
├─ AggregateId (Index)
├─ EventType
├─ EventData (JSON)
├─ OccurredAt (Index)
├─ Version
└─ CreatedAt
```

### Read Model（読み取り用）

**初期実装のテーブル構成:**

```sql
Projects テーブル
├─ ProjectId (PK)
├─ Title
├─ Description
├─ CreatedAt
└─ UpdatedAt

Tasks テーブル
├─ TaskId (PK)
├─ ProjectId (FK, Index)
├─ Title
├─ Description
├─ Status
├─ PlannedStartDate
├─ PlannedEndDate
├─ EstimatedHours
├─ ActualStartDate
├─ ActualEndDate
├─ ActualHours
├─ CreatedAt
└─ UpdatedAt
```

**注意:** AssignedTo、Priority、ProgressPercentage、TaskDependenciesは将来実装

### データ同期（Projection層の役割）

**原則:**
- Projection層がDomain EventをサブスクライブしてRead Modelを更新
- Event Store → Projection → Read Model の一方向フロー
- ReadModelは再構築可能（イベントから復元）
- Write側とRead側は完全に分離

**アーキテクチャフロー:**
```
1. Command → Aggregate → Domain Event発行
2. Domain Event → Event Storeに保存（Infrastructure.Write）
3. Domain Event → Projection層がサブスクライブ
4. Projection → Read Model DBに反映（Infrastructure.Read）
5. Query → Read Model DBから読み取り（Infrastructure.Read）
```

**Projection層の実装例:**
```csharp
// RewindPM.Projection
public class TaskProjection
{
    private readonly ReadModelDbContext _readContext;

    public async Task Handle(TaskCreated @event)
    {
        var task = new TaskReadModel
        {
            TaskId = @event.TaskId,
            ProjectId = @event.ProjectId,
            Title = @event.Title,
            Description = @event.Description,
            Status = TaskStatus.Todo,
            CreatedAt = @event.OccurredAt
        };

        await _readContext.Tasks.AddAsync(task);
        await _readContext.SaveChangesAsync();
    }

    public async Task Handle(TaskStatusChanged @event)
    {
        var task = await _readContext.Tasks.FindAsync(@event.TaskId);
        if (task != null)
        {
            task.Status = @event.NewStatus;
            task.UpdatedAt = @event.OccurredAt;
            await _readContext.SaveChangesAsync();
        }
    }
}
```

**注意:** Projection層はInfrastructure.Readに依存し、Read Model DBに書き込みを行う唯一の場所です。

---

## UI/UX設計方針

UI/UXの詳細仕様は[UI_MVP.md](UI_MVP.md)を参照。

### Blazor Server選択理由

**利点:**
- ZIP提出に最適（単一アプリケーション）
- SignalRが標準搭載（リアルタイム更新）
- サーバー側で完結（セキュリティ）
- イベントストアへの直接アクセス

### 設計原則

**コンポーネント設計:**
- 再利用可能なコンポーネント化
- 責務の明確な分離
- MediatRで疎結合

**デザインベンチマーク:**
- GitHubのプロジェクト管理機能をイメージ
- シンプルで直感的な操作性
- モダンなカード型レイアウト

---

## テスト戦略

### テストピラミッド

```
        /\
       /  \  E2E Tests (少数)
      /────\
     / UI   \ Integration Tests (中程度)
    /────────\
   /  Domain  \ Unit Tests (多数)
  /────────────\
```

### レイヤー別テスト方針

**Domain Layer（80%以上のカバレッジ目標）**
- Aggregateのビジネスロジック
- イベント適用ロジック
- Value Objectのバリデーション

```csharp
[Fact]
public void Complete_WhenAlreadyCompleted_ShouldThrowDomainException()
{
    // Arrange
    var task = TaskAggregate.Create(Guid.NewGuid(), Guid.NewGuid(), "Test", "");
    task.Complete("user1", 10);
    
    // Act & Assert
    var act = () => task.Complete("user2", 5);
    act.Should().Throw<DomainException>()
        .WithMessage("既に完了しています");
}
```

**Application Layer（70%以上のカバレッジ目標）**
- コマンドハンドラー
- クエリハンドラー
- バリデーター

```csharp
[Fact]
public async Task Handle_ValidCommand_ShouldCreateTask()
{
    // Arrange
    var command = new CreateTaskCommand(
        Guid.NewGuid(), "Task", "Description", "user");

    // Act
    var taskId = await _handler.Handle(command, CancellationToken.None);

    // Assert
    taskId.Should().NotBeEmpty();
    var events = await _eventStore.GetEventsAsync(taskId);
    events.Should().ContainSingle(e => e is TaskCreated);
}
```

**Infrastructure Layer（50%以上のカバレッジ目標）**
- Event Storeの動作
- ReadModelの更新
- 統合テスト

```csharp
[Fact]
public async Task GetEventsUntilAsync_ShouldReturnEventsBeforeTime()
{
    // Arrange
    var taskId = Guid.NewGuid();
    var event1 = new TaskCreated(taskId, /*...*/);
    var event2 = new TaskStatusChanged(taskId, /*...*/);
    
    await _eventStore.SaveEventsAsync(taskId, new[] { event1 }, 0);
    await Task.Delay(100);
    var cutoffTime = DateTime.UtcNow;
    await Task.Delay(100);
    await _eventStore.SaveEventsAsync(taskId, new[] { event2 }, 1);
    
    // Act
    var events = await _eventStore.GetEventsUntilAsync(taskId, cutoffTime);
    
    // Assert
    events.Should().HaveCount(1);
    events.First().Should().BeOfType<TaskCreated>();
}
```

### テストフレームワーク

**xUnit**
- 安定性と実績
- 豊富なエコシステム
- .NETの標準的なテストフレームワーク
- 企業での採用実績

---

## Git運用方針

### ブランチ戦略

```
main (安定版)
  ↑ マージ（マイルストーン達成時）
develop (開発ブランチ)
  ↑ 直接プッシュ
feature/* (大きな機能のみ)
```

### コミットメッセージ規約

```
<type>(<scope>): <subject>

例:
feat(domain): TaskAggregateにスケジュール機能を追加
fix(application): タスク完了時のバリデーションを修正
refactor(infrastructure): Event Storeのクエリを最適化
test(application): CreateTaskHandlerのテストを追加
docs: READMEにセットアップ手順を追加
chore: CI/CD設定を追加
```

### CI/CD

**GitHub Actionsで自動化:**
- プッシュ時にビルド・テスト実行
- コードカバレッジ測定
- コードフォーマットチェック
- タグ付け時にリリースビルド作成
---

## セキュリティ考慮事項

### 認証・認可（簡易実装）

**方針:**
- MVP段階ではユーザーIDをハードコード
- 将来的にASP.NET Core Identityを統合可能な設計

### データ保護

**原則:**
- イベントデータに機密情報を含めない
- ローカルSQLiteなので暗号化は不要
- 本番環境ではSQL Serverなどを検討

### 入力検証

**多層防御:**
- UI層での基本チェック
- Application層での厳密なバリデーション
- Domain層での不変条件保護

---

## パフォーマンス方針

### 最適化戦略

**イベントリプレイ:**
- イベント数が多い場合はスナップショット（将来）
- よくアクセスされる時点はキャッシュ
- 並列処理でのリプレイ（複数Aggregate）

**ReadModel:**
- 適切なインデックス設定
- クエリの最適化
- N+1問題の回避

**Blazor Server:**
- SignalRの接続管理
- 不要な再レンダリングの抑制
- StateHasChanged()の適切な使用

---

## 開発マイルストーン

### Phase 1: 基盤（v0.1.0 - v0.3.0）
- ✅ プロジェクト構造の作成
- ✅ CI/CDの設定
- ドメイン層実装
- CQRS基盤
- イベントソーシング
- 基本UI
- タイムトラベル機能

**目標:** 転職活動で最低限見せられるレベル

### Phase 2: 機能拡充（v0.4.0 - v0.7.0）
- 担当者・優先度・進捗率の追加
- タスク間の依存関係管理
- カンバンビュー
- 分析・比較機能

**目標:** しっかりアピールできるレベル

### Phase 3: 仕上げ（v0.8.0 - v1.0.0）
- コラボレーション機能
- 品質向上
- ドキュメント整備
- リリース

**目標:** 完璧な状態
---

## 技術的な挑戦と学び

### このプロジェクトで示せる技術力

**アーキテクチャ:**
- Clean Architecture + DDD
- CQRS/Event Sourcing
- レイヤー間の適切な責務分離

**実装力:**
- .NET 10の最新機能活用
- 非同期プログラミング
- 適切なデザインパターン使用

**品質管理:**
- 高いテストカバレッジ
- CI/CD自動化
- コード品質の維持

**問題解決力:**
- タイムトラベル機能という独自要件
- イベントソーシングの実践的実装
- パフォーマンスとのバランス

---

## ドキュメント管理

### READMEに含めるべき内容

- プロジェクト概要
- 主な機能
- アーキテクチャ概要
- 技術スタック
- セットアップ手順
- 使い方
- スクリーンショット
- 設計判断の記録
- ライセンス

### 追加ドキュメント（将来作成）

```
docs/
├─ ARCHITECTURE.md (詳細設計)
├─ API.md (コマンド・クエリ一覧)
├─ EVENT_CATALOG.md (全イベント一覧)
└─ MIGRATION.md (MediatR移行記録)
```

---

## まとめ：設計の核心原則

1. **イベントソーシングファースト**
   - すべての変更をイベントとして記録し、過去の追跡を可能にする

2. **責務の明確な分離**
   - 各レイヤーの役割を厳密に守り、依存関係を制御する

3. **バリデーションの多層防御**
   - UI → Application → Domainの3層で段階的にチェック

4. **テスタビリティの重視**
   - 高いカバレッジを維持し、リファクタリングを容易にする

5. **実用性と学習のバランス**
   - ポートフォリオとして技術力を示しつつ、実用的なツールを作る