<div class="timeline-toolbar @(IsViewingPast ? "viewing-past" : "")">
    <button
        class="timeline-btn timeline-btn-prev"
        @onclick="MoveToPrevious"
        disabled="@(!CanMoveToPrevious)"
        title="前の編集日へ"
        type="button">
        ◀
    </button>

    <div class="timeline-info">
        @if (CurrentDate.HasValue)
        {
            <span class="timeline-date">@CurrentDate.Value.ToString("yyyy/MM/dd")</span>
            <span class="timeline-badge">過去の状態</span>
        }
        else
        {
            <span class="timeline-date">最新</span>
            <span class="timeline-badge badge-live">現在の状態</span>
        }
    </div>

    <button
        class="timeline-btn timeline-btn-next"
        @onclick="MoveToNext"
        disabled="@(!CanMoveToNext)"
        title="次の編集日へ"
        type="button">
        ▶
    </button>

    <button
        class="timeline-btn timeline-btn-reset @(!IsViewingPast ? "btn-hidden" : "")"
        @onclick="MoveToLatest"
        title="最新状態に戻る"
        type="button">
        最新に戻る
    </button>
</div>

@* スライドバーコントロール *@
@if (EditDates != null && EditDates.Count > 0)
{
    <div class="timeline-slider-container">
        <div class="timeline-slider-labels">
            @foreach (var label in GetSliderLabels())
            {
                <span class="slider-label" style="left: @(label.Position)%">@label.Text</span>
            }
        </div>
        <input
            type="range"
            class="timeline-slider"
            min="0"
            max="@MaxSliderValue"
            value="@CurrentSliderValue"
            @onchange="HandleSliderChange"
            aria-label="日付スライダー"
            title="@GetSliderTooltip()" />
        <div class="timeline-slider-ticks">
            @for (int i = 0; i <= MaxSliderValue; i++)
            {
                <div class="slider-tick @(i == CurrentSliderValue ? "active" : "")"
                     style="left: @(GetTickPosition(i))%"></div>
            }
        </div>
    </div>
}

@inject ILogger<TimelineControl> Logger

@code {
    /// <summary>
    /// 現在表示中の日付（nullの場合は最新）
    /// </summary>
    [Parameter]
    public DateTimeOffset? CurrentDate { get; set; }

    /// <summary>
    /// 編集日一覧（降順：新しい順）
    /// </summary>
    [Parameter]
    public List<DateTimeOffset> EditDates { get; set; } = new();

    /// <summary>
    /// 日付変更イベント
    /// </summary>
    [Parameter]
    public EventCallback<DateTimeOffset?> OnDateChanged { get; set; }

    /// <summary>
    /// 過去を表示中かどうか
    /// </summary>
    private bool IsViewingPast => CurrentDate.HasValue;

    /// <summary>
    /// スライドバーの最大値（0が最古、MaxSliderValueが最新）
    /// </summary>
    private int MaxSliderValue => EditDates?.Count ?? 0;

    /// <summary>
    /// 現在のスライドバーの値
    /// </summary>
    private int CurrentSliderValue
    {
        get
        {
            if (!CurrentDate.HasValue)
                return MaxSliderValue; // 最新（右端）

            // EditDatesリストでのインデックスを検索（降順リストなので反転）
            var index = EditDates?.FindIndex(d => d.Date == CurrentDate.Value.Date) ?? -1;
            if (index >= 0)
            {
                // 反転: 0番目（最新の編集日）→MaxSliderValue-1、最後（最古）→0
                return MaxSliderValue - 1 - index;
            }
            return MaxSliderValue; // 見つからない場合は最新
        }
    }

    private const string LiveStateLabel = "最新の状態";
    private const string DateFormat = "yyyy/MM/dd";
    private const string ShortDateFormat = "MM/dd";
    private const int MaxSliderLabels = 7;

    /// <summary>
    /// 前の編集日へ移動可能かどうか
    /// </summary>
    private bool CanMoveToPrevious
    {
        get
        {
            if (!HasEditDates)
                return false;

            if (IsViewingLatest)
                return EditDates.Count > 0;

            return HasOlderDates();
        }
    }

    /// <summary>
    /// 次の編集日へ移動可能かどうか
    /// </summary>
    private bool CanMoveToNext => IsViewingPast;

    private bool HasEditDates => EditDates != null && EditDates.Count > 0;
    private bool IsViewingLatest => !CurrentDate.HasValue;
    private bool HasOlderDates() => EditDates.Any(d => d < CurrentDate!.Value);

    /// <summary>
    /// 前の編集日（より古い日付）へ移動
    /// </summary>
    private async Task MoveToPrevious()
    {
        if (!CanMoveToPrevious)
            return;

        DateTimeOffset? newDate;

        if (!CurrentDate.HasValue)
        {
            // 最新表示中の場合、最新の編集日（リストの先頭）へ
            newDate = EditDates.FirstOrDefault();
        }
        else
        {
            // 現在の日付より古い日付のうち、最も新しいものを取得
            newDate = EditDates
                .Where(d => d < CurrentDate.Value)
                .OrderByDescending(d => d)
                .FirstOrDefault();
        }

        if (newDate != default(DateTimeOffset))
        {
            await OnDateChanged.InvokeAsync(newDate);
        }
    }

    /// <summary>
    /// 次の編集日（より新しい日付）へ移動。最新の編集日より後は「最新状態」に戻る。
    /// </summary>
    private async Task MoveToNext()
    {
        if (!CanMoveToNext)
            return;

        var newDate = EditDates
            .Where(d => d > CurrentDate!.Value)
            .OrderBy(d => d)
            .FirstOrDefault();

        // もし新しい日付がなければ（＝現在が最新の過去スナップショット）、
        // または見つからなければ、最新状態(null)に戻る
        if (newDate == default(DateTimeOffset))
        {
            await MoveToLatest();
        }
        else
        {
            await OnDateChanged.InvokeAsync(newDate);
        }
    }

    /// <summary>
    /// 最新状態に戻る
    /// </summary>
    private async Task MoveToLatest()
    {
        await OnDateChanged.InvokeAsync(null);
    }

    /// <summary>
    /// スライドバーの変更完了イベント（マウスアップ時）
    /// </summary>
    private async Task HandleSliderChange(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            await MoveToSliderValue(value);
        }
    }

    /// <summary>
    /// スライダー値に対応する日付へ移動
    /// </summary>
    private async Task MoveToSliderValue(int sliderValue)
    {
        if (sliderValue == MaxSliderValue)
        {
            // 最新状態（右端）
            await OnDateChanged.InvokeAsync(null);
        }
        else if (sliderValue >= 0 && sliderValue < MaxSliderValue)
        {
            // 反転してインデックスを計算: sliderValue 0（左端）→最後のインデックス
            var index = MaxSliderValue - 1 - sliderValue;
            if (index >= 0 && index < EditDates.Count)
            {
                var targetDate = EditDates[index];
                await OnDateChanged.InvokeAsync(targetDate);
            }
        }
    }

    /// <summary>
    /// スライダーの目盛り位置を計算
    /// </summary>
    private double GetTickPosition(int index)
    {
        if (MaxSliderValue == 0)
            return 0;
        return (double)index / MaxSliderValue * 100;
    }

    /// <summary>
    /// スライダーのツールチップテキスト
    /// </summary>
    private string GetSliderTooltip()
    {
        if (CurrentSliderValue == MaxSliderValue)
            return LiveStateLabel;

        if (TryGetEditDateAtSliderValue(CurrentSliderValue, out var date))
        {
            return date.ToString(DateFormat);
        }

        return string.Empty;
    }

    /// <summary>
    /// スライドバーに表示するラベルのリストを生成
    /// </summary>
    private List<SliderLabel> GetSliderLabels()
    {
        var labels = new List<SliderLabel>();

        if (!HasEditDates)
            return labels;

        var totalPositions = MaxSliderValue + 1;

        // 表示する間隔を計算
        int interval = 1;

        if (totalPositions > MaxSliderLabels)
        {
            // 生成されるラベル数がMaxSliderLabels以下になる最小のintervalを求める
            interval = (int)Math.Ceiling((double)MaxSliderValue / (MaxSliderLabels - 1));
        }

        // 等間隔にラベルを配置
        for (int i = 0; i <= MaxSliderValue; i += interval)
        {
            var position = GetTickPosition(i);
            string text;

            if (i == MaxSliderValue)
            {
                // 最新状態（最新の編集日を表示）
                text = EditDates!.First().ToString(ShortDateFormat);
            }
            else if (TryGetEditDateAtSliderValue(i, out var date))
            {
                // 編集日
                text = date.ToString(ShortDateFormat);
            }
            else
            {
                // ここに到達するのは想定外。
                // GetTickPosition は 0〜MaxSliderValue の連続値を前提としており、
                // sliderValue < MaxSliderValue の範囲では必ず有効な編集日が存在する設計である。
                Logger.LogWarning(
                    "TryGetEditDateAtSliderValue が想定外に false を返しました。sliderValue={SliderValue}, MaxSliderValue={MaxSliderValue}, EditDatesCount={EditDatesCount}",
                    i, MaxSliderValue, EditDates?.Count);
                continue; // 想定外だが、UI の破綻を避けるため当該位置のラベルは描画しない
            }

            labels.Add(new SliderLabel(position, text, i));
        }

        // 最後の位置（MaxSliderValue）がループで含まれていない場合は追加
        if (MaxSliderValue % interval != 0)
        {
            var position = GetTickPosition(MaxSliderValue);
            var text = EditDates!.First().ToString(ShortDateFormat);
            labels.Add(new SliderLabel(position, text, MaxSliderValue));
        }

        return labels;
    }

    /// <summary>
    /// スライダーラベルの情報
    /// </summary>
    private record SliderLabel(double Position, string Text, int SliderValue);

    private bool TryGetEditDateAtSliderValue(int sliderValue, out DateTimeOffset date)
    {
        date = default;
        if (sliderValue < 0 || sliderValue >= MaxSliderValue)
            return false;

        var index = MaxSliderValue - 1 - sliderValue;
        if (!IsValidEditDateIndex(index))
            return false;

        date = EditDates[index];
        return true;
    }

    private bool IsValidEditDateIndex(int index)
    {
        return index >= 0 && index < EditDates?.Count;
    }
}
