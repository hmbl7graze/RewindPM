<div class="timeline-toolbar @(IsViewingPast ? "viewing-past" : "")">
    <button
        class="timeline-btn timeline-btn-prev"
        @onclick="MoveToPrevious"
        disabled="@(!CanMoveToPrevious)"
        title="前の編集日へ"
        type="button">
        ◀
    </button>

    <div class="timeline-info">
        @if (CurrentDate.HasValue)
        {
            <span class="timeline-date">@CurrentDate.Value.ToString("yyyy/MM/dd")</span>
            <span class="timeline-badge">過去の状態</span>
        }
        else
        {
            <span class="timeline-date">最新</span>
            <span class="timeline-badge badge-live">現在の状態</span>
        }
    </div>

    <button
        class="timeline-btn timeline-btn-next"
        @onclick="MoveToNext"
        disabled="@(!CanMoveToNext)"
        title="次の編集日へ"
        type="button">
        ▶
    </button>

    @if (IsViewingPast)
    {
        <button
            class="timeline-btn timeline-btn-reset"
            @onclick="MoveToLatest"
            title="最新状態に戻る"
            type="button">
            最新に戻る
        </button>
    }
</div>

@* スライドバーコントロール *@
@if (EditDates != null && EditDates.Count > 0)
{
    <div class="timeline-slider-container">
        <div class="timeline-slider-labels">
            <span class="slider-label slider-label-start">最古</span>
            <span class="slider-label slider-label-center">@GetCenterDateLabel()</span>
            <span class="slider-label slider-label-end">最新</span>
        </div>
        <input
            type="range"
            class="timeline-slider"
            min="0"
            max="@MaxSliderValue"
            value="@CurrentSliderValue"
            @oninput="HandleSliderInput"
            @onchange="HandleSliderChange"
            aria-label="日付スライダー"
            title="@GetSliderTooltip()" />
        <div class="timeline-slider-ticks">
            @for (int i = 0; i <= MaxSliderValue; i++)
            {
                <div class="slider-tick @(i == CurrentSliderValue ? "active" : "")" 
                     style="left: @(GetTickPosition(i))%"></div>
            }
        </div>
    </div>
}

@code {
    /// <summary>
    /// 現在表示中の日付（nullの場合は最新）
    /// </summary>
    [Parameter]
    public DateTime? CurrentDate { get; set; }

    /// <summary>
    /// 編集日一覧（降順：新しい順）
    /// </summary>
    [Parameter]
    public List<DateTime> EditDates { get; set; } = new();

    /// <summary>
    /// 日付変更イベント
    /// </summary>
    [Parameter]
    public EventCallback<DateTime?> OnDateChanged { get; set; }

    /// <summary>
    /// 過去を表示中かどうか
    /// </summary>
    private bool IsViewingPast => CurrentDate.HasValue;

    /// <summary>
    /// スライドバーの最大値（0が最古、MaxSliderValueが最新）
    /// </summary>
    private int MaxSliderValue => EditDates?.Count ?? 0;

    /// <summary>
    /// 現在のスライドバーの値
    /// </summary>
    private int CurrentSliderValue
    {
        get
        {
            if (!CurrentDate.HasValue)
                return MaxSliderValue; // 最新（右端）

            // EditDatesリストでのインデックスを検索（降順リストなので反転）
            var index = EditDates?.FindIndex(d => d.Date == CurrentDate.Value.Date) ?? -1;
            if (index >= 0)
            {
                // 反転: 0番目（最新の編集日）→MaxSliderValue-1、最後（最古）→0
                return MaxSliderValue - 1 - index;
            }
            return MaxSliderValue; // 見つからない場合は最新
        }
    }

    /// <summary>
    /// スライドバー操作中の一時的な値（デバウンス用）
    /// </summary>
    private int _pendingSliderValue = 0;

    /// <summary>
    /// 前の編集日へ移動可能かどうか
    /// </summary>
    private bool CanMoveToPrevious
    {
        get
        {
            if (EditDates == null || EditDates.Count == 0)
                return false;

            if (!CurrentDate.HasValue)
            {
                // 最新表示中の場合、編集日があれば移動可能
                return EditDates.Count > 0;
            }

            // 現在の日付より古い日付が存在するか確認
            return EditDates.Any(d => d < CurrentDate.Value);
        }
    }

    /// <summary>
    /// 次の編集日へ移動可能かどうか
    /// </summary>
    private bool CanMoveToNext
    {
        get
        {
            // If viewing past, we can always move "next" at least to the Live state
            // unless we are already at Live state (CurrentDate is null)
            if (!CurrentDate.HasValue)
                return false;

            // If we are viewing a past date, we can definitely move "next".
            // Even if there are no newer EditDates, the "Next" step is "Live".
            return true;
        }
    }

    /// <summary>
    /// 前の編集日（より古い日付）へ移動
    /// </summary>
    private async Task MoveToPrevious()
    {
        if (!CanMoveToPrevious)
            return;

        DateTime? newDate;

        if (!CurrentDate.HasValue)
        {
            // 最新表示中の場合、最新の編集日（リストの先頭）へ
            newDate = EditDates.FirstOrDefault();
        }
        else
        {
            // 現在の日付より古い日付のうち、最も新しいものを取得
            newDate = EditDates
                .Where(d => d < CurrentDate.Value)
                .OrderByDescending(d => d)
                .FirstOrDefault();
        }

        if (newDate != default(DateTime))
        {
            await OnDateChanged.InvokeAsync(newDate);
        }
    }

    /// <summary>
    /// 次の編集日（より新しい日付）へ移動
    /// </summary>
    /// <summary>
    /// 次の編集日（より新しい日付）へ移動。最新の編集日より後は「最新状態」に戻る。
    /// </summary>
    private async Task MoveToNext()
    {
        if (!CanMoveToNext)
            return;

        // 現在の日付より新しい日付のうち、最も古いものを取得
        var newDate = EditDates
            .Where(d => d > CurrentDate!.Value)
            .OrderBy(d => d)
            .FirstOrDefault();

        // もし新しい日付がなければ（＝現在が最新の過去スナップショット）、
        // または見つからなければ、最新状態(null)に戻る
        if (newDate == default(DateTime))
        {
            await MoveToLatest();
        }
        else
        {
            await OnDateChanged.InvokeAsync(newDate);
        }
    }

    /// <summary>
    /// 最新状態に戻る
    /// </summary>
    private async Task MoveToLatest()
    {
        await OnDateChanged.InvokeAsync(null);
    }

    /// <summary>
    /// スライドバーの入力イベント（ドラッグ中）
    /// </summary>
    private void HandleSliderInput(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            _pendingSliderValue = value;
            // ドラッグ中はUIのみ更新（データ取得は行わない）
        }
    }

    /// <summary>
    /// スライドバーの変更完了イベント（マウスアップ時）
    /// </summary>
    private async Task HandleSliderChange(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            await MoveToSliderValue(value);
        }
    }

    /// <summary>
    /// スライダー値に対応する日付へ移動
    /// </summary>
    private async Task MoveToSliderValue(int sliderValue)
    {
        if (sliderValue == MaxSliderValue)
        {
            // 最新状態（右端）
            await OnDateChanged.InvokeAsync(null);
        }
        else if (sliderValue >= 0 && sliderValue < MaxSliderValue)
        {
            // 反転してインデックスを計算: sliderValue 0（左端）→最後のインデックス
            var index = MaxSliderValue - 1 - sliderValue;
            if (index >= 0 && index < EditDates.Count)
            {
                var targetDate = EditDates[index];
                await OnDateChanged.InvokeAsync(targetDate);
            }
        }
    }

    /// <summary>
    /// スライダーの目盛り位置を計算
    /// </summary>
    private double GetTickPosition(int index)
    {
        if (MaxSliderValue == 0)
            return 0;
        return (double)index / MaxSliderValue * 100;
    }

    /// <summary>
    /// スライダーのツールチップテキスト
    /// </summary>
    private string GetSliderTooltip()
    {
        if (CurrentSliderValue == MaxSliderValue)
            return "最新の状態";
        if (CurrentSliderValue >= 0 && CurrentSliderValue < MaxSliderValue)
        {
            var index = MaxSliderValue - 1 - CurrentSliderValue;
            if (index >= 0 && index < EditDates?.Count)
                return EditDates[index].ToString("yyyy/MM/dd");
        }
        return "";
    }

    /// <summary>
    /// スライダー中央のラベルを取得
    /// </summary>
    private string GetCenterDateLabel()
    {
        if (EditDates == null || EditDates.Count == 0)
            return "";

        var middleIndex = EditDates.Count / 2;
        if (middleIndex >= 0 && middleIndex < EditDates.Count)
        {
            return EditDates[middleIndex].ToString("MM/dd");
        }
        return "";
    }
}
