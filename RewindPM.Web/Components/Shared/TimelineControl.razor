<div class="timeline-toolbar @(IsViewingPast ? "viewing-past" : "")" @onclick="HandleToolbarClick">
    <div class="timeline-calendar-wrapper">
        <button
            class="timeline-btn timeline-btn-calendar"
            @onclick="ToggleCalendarPicker"
            @onclick:stopPropagation="true"
            disabled="@(!HasEditDates)"
            title="ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰æ—¥ä»˜ã‚’é¸æŠ"
            aria-label="ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‹ã‚‰æ—¥ä»˜ã‚’é¸æŠ"
            type="button">
            <span role="img" aria-hidden="true">ğŸ“…</span>
        </button>

        @if (_isCalendarOpen)
        {
            <div class="timeline-calendar-dropdown" @onclick:stopPropagation="true" role="dialog" aria-modal="true" aria-label="æ—¥ä»˜é¸æŠã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼">
                <div class="calendar-header">
                    <button class="calendar-nav-btn" @onclick="PreviousMonth" type="button" aria-label="å‰ã®æœˆã¸">â—€</button>
                    <div class="calendar-month-year">
                        @_displayMonth.ToString("yyyyå¹´ Mæœˆ")
                    </div>
                    <button class="calendar-nav-btn" @onclick="NextMonth" type="button" aria-label="æ¬¡ã®æœˆã¸">â–¶</button>
                </div>
                <div class="calendar-grid">
                    <div class="calendar-weekdays">
                        <div class="calendar-weekday">æ—¥</div>
                        <div class="calendar-weekday">æœˆ</div>
                        <div class="calendar-weekday">ç«</div>
                        <div class="calendar-weekday">æ°´</div>
                        <div class="calendar-weekday">æœ¨</div>
                        <div class="calendar-weekday">é‡‘</div>
                        <div class="calendar-weekday">åœŸ</div>
                    </div>
                    <div class="calendar-days">
                        @foreach (var day in GetCalendarDays())
                        {
                            <button
                                class="calendar-day @GetDayClass(day)"
                                @onclick="() => SelectDate(day)"
                                disabled="@(!IsDateSelectable(day))"
                                aria-label="@GetDayAriaLabel(day)"
                                aria-pressed="@(CurrentDate.HasValue && day.Date == CurrentDate.Value.Date ? "true" : "false")"
                                type="button">
                                @(day.Day)
                            </button>
                        }
                    </div>
                </div>
            </div>
        }
    </div>

    <button
        class="timeline-btn timeline-btn-prev"
        @onclick="MoveToPrevious"
        disabled="@(!CanMoveToPrevious)"
        title="å‰ã®ç·¨é›†æ—¥ã¸"
        type="button">
        â—€
    </button>

    <div class="timeline-info">
        @if (CurrentDate.HasValue)
        {
            <span class="timeline-date">@CurrentDate.Value.ToString("yyyy/MM/dd")</span>
            <span class="timeline-badge">éå»ã®çŠ¶æ…‹</span>
        }
        else
        {
            <span class="timeline-date">æœ€æ–°</span>
            <span class="timeline-badge badge-live">ç¾åœ¨ã®çŠ¶æ…‹</span>
        }
    </div>

    <button
        class="timeline-btn timeline-btn-next"
        @onclick="MoveToNext"
        disabled="@(!CanMoveToNext)"
        title="æ¬¡ã®ç·¨é›†æ—¥ã¸"
        type="button">
        â–¶
    </button>

    <button
        class="timeline-btn timeline-btn-reset @(!IsViewingPast ? "btn-hidden" : "")"
        @onclick="MoveToLatest"
        title="æœ€æ–°çŠ¶æ…‹ã«æˆ»ã‚‹"
        type="button">
        æœ€æ–°ã«æˆ»ã‚‹
    </button>
</div>

@* ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« *@
@if (EditDates != null && EditDates.Count > 0)
{
    <div class="timeline-slider-container">
        <div class="timeline-slider-labels">
            @foreach (var label in GetSliderLabels())
            {
                <span class="slider-label" style="left: @(label.Position)%">@label.Text</span>
            }
        </div>
        <input
            type="range"
            class="timeline-slider"
            min="0"
            max="@MaxSliderValue"
            value="@CurrentSliderValue"
            @onchange="HandleSliderChange"
            aria-label="æ—¥ä»˜ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼" />
        <div class="timeline-slider-ticks">
            @for (int i = 0; i <= MaxSliderValue; i++)
            {
                <div class="slider-tick @(i == CurrentSliderValue ? "active" : "")"
                     style="left: @(GetTickPosition(i))%"></div>
            }
        </div>
    </div>
}

@inject ILogger<TimelineControl> Logger

@code {
    private bool _isCalendarOpen = false;
    private DateTime _displayMonth;
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„: EditDatesã‚’HashSetã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    private HashSet<DateTime>? _editDatesCache;
    private DateTime? _minDate;
    private DateTime? _maxDate;
    private List<DateTime>? _cachedCalendarDays;
    private DateTime _cachedCalendarMonth = DateTime.MinValue;

    /// <summary>
    /// ç¾åœ¨è¡¨ç¤ºä¸­ã®æ—¥ä»˜(nullã®å ´åˆã¯æœ€æ–°)
    /// </summary>
    [Parameter]
    public DateTimeOffset? CurrentDate { get; set; }

    /// <summary>
    /// ç·¨é›†æ—¥ä¸€è¦§(é™é †:æ–°ã—ã„é †)
    /// </summary>
    [Parameter]
    public List<DateTimeOffset> EditDates { get; set; } = new();

    /// <summary>
    /// æ—¥ä»˜å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
    /// </summary>
    [Parameter]
    public EventCallback<DateTimeOffset?> OnDateChanged { get; set; }

    /// <summary>
    /// éå»ã‚’è¡¨ç¤ºä¸­ã‹ã©ã†ã‹
    /// </summary>
    private bool IsViewingPast => CurrentDate.HasValue;

    /// <summary>
    /// ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼ã®æœ€å¤§å€¤(0ãŒæœ€å¤ã€MaxSliderValueãŒæœ€æ–°)
    /// </summary>
    private int MaxSliderValue => EditDates?.Count ?? 0;

    /// <summary>
    /// ç¾åœ¨ã®ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼ã®å€¤
    /// </summary>
    private int CurrentSliderValue
    {
        get
        {
            if (!CurrentDate.HasValue)
                return MaxSliderValue; // æœ€æ–°ï¼ˆå³ç«¯ï¼‰

            // EditDatesãƒªã‚¹ãƒˆã§ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¤œç´¢ï¼ˆé™é †ãƒªã‚¹ãƒˆãªã®ã§åè»¢ï¼‰
            var index = EditDates?.FindIndex(d => d.Date == CurrentDate.Value.Date) ?? -1;
            if (index >= 0)
            {
                // åè»¢: 0ç•ªç›®ï¼ˆæœ€æ–°ã®ç·¨é›†æ—¥ï¼‰â†’MaxSliderValue-1ã€æœ€å¾Œï¼ˆæœ€å¤ï¼‰â†’0
                return MaxSliderValue - 1 - index;
            }
            return MaxSliderValue; // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯æœ€æ–°
        }
    }

    private const string LiveStateLabel = "æœ€æ–°ã®çŠ¶æ…‹";
    private const string DateFormat = "yyyy/MM/dd";
    private const string ShortDateFormat = "MM/dd";
    private const int MaxSliderLabels = 7;

    /// <summary>
    /// å‰ã®ç·¨é›†æ—¥ã¸ç§»å‹•å¯èƒ½ã‹ã©ã†ã‹
    /// </summary>
    private bool CanMoveToPrevious
    {
        get
        {
            if (!HasEditDates)
                return false;

            if (IsViewingLatest)
                return EditDates.Count > 0;

            return HasOlderDates();
        }
    }

    /// <summary>
    /// æ¬¡ã®ç·¨é›†æ—¥ã¸ç§»å‹•å¯èƒ½ã‹ã©ã†ã‹
    /// </summary>
    private bool CanMoveToNext => IsViewingPast;

    private bool HasEditDates => EditDates != null && EditDates.Count > 0;
    private bool IsViewingLatest => !CurrentDate.HasValue;
    private bool HasOlderDates() => EditDates.Any(d => d < CurrentDate!.Value);

    /// <summary>
    /// å‰ã®ç·¨é›†æ—¥ï¼ˆã‚ˆã‚Šå¤ã„æ—¥ä»˜ï¼‰ã¸ç§»å‹•
    /// </summary>
    private async Task MoveToPrevious()
    {
        if (!CanMoveToPrevious)
            return;

        DateTimeOffset? newDate;

        if (!CurrentDate.HasValue)
        {
            // æœ€æ–°è¡¨ç¤ºä¸­ã®å ´åˆã€æœ€æ–°ã®ç·¨é›†æ—¥ï¼ˆãƒªã‚¹ãƒˆã®å…ˆé ­ï¼‰ã¸
            newDate = EditDates.FirstOrDefault();
        }
        else
        {
            // ç¾åœ¨ã®æ—¥ä»˜ã‚ˆã‚Šå¤ã„æ—¥ä»˜ã®ã†ã¡ã€æœ€ã‚‚æ–°ã—ã„ã‚‚ã®ã‚’å–å¾—
            newDate = EditDates
                .Where(d => d < CurrentDate.Value)
                .OrderByDescending(d => d)
                .FirstOrDefault();
        }

        if (newDate != default(DateTimeOffset))
        {
            await OnDateChanged.InvokeAsync(newDate);
        }
    }

    /// <summary>
    /// æ¬¡ã®ç·¨é›†æ—¥ï¼ˆã‚ˆã‚Šæ–°ã—ã„æ—¥ä»˜ï¼‰ã¸ç§»å‹•ã€‚æœ€æ–°ã®ç·¨é›†æ—¥ã‚ˆã‚Šå¾Œã¯ã€Œæœ€æ–°çŠ¶æ…‹ã€ã«æˆ»ã‚‹ã€‚
    /// </summary>
    private async Task MoveToNext()
    {
        if (!CanMoveToNext)
            return;

        var newDate = EditDates
            .Where(d => d > CurrentDate!.Value)
            .OrderBy(d => d)
            .FirstOrDefault();

        // ã‚‚ã—æ–°ã—ã„æ—¥ä»˜ãŒãªã‘ã‚Œã°ï¼ˆï¼ç¾åœ¨ãŒæœ€æ–°ã®éå»ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆï¼‰ã€
        // ã¾ãŸã¯è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€æœ€æ–°çŠ¶æ…‹(null)ã«æˆ»ã‚‹
        if (newDate == default(DateTimeOffset))
        {
            await MoveToLatest();
        }
        else
        {
            await OnDateChanged.InvokeAsync(newDate);
        }
    }

    /// <summary>
    /// æœ€æ–°çŠ¶æ…‹ã«æˆ»ã‚‹
    /// </summary>
    private async Task MoveToLatest()
    {
        await OnDateChanged.InvokeAsync(null);
    }

    /// <summary>
    /// ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼ã®å¤‰æ›´å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—æ™‚ï¼‰
    /// </summary>
    private async Task HandleSliderChange(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            await MoveToSliderValue(value);
        }
    }

    /// <summary>
    /// ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å€¤ã«å¯¾å¿œã™ã‚‹æ—¥ä»˜ã¸ç§»å‹•
    /// </summary>
    private async Task MoveToSliderValue(int sliderValue)
    {
        if (sliderValue == MaxSliderValue)
        {
            // æœ€æ–°çŠ¶æ…‹ï¼ˆå³ç«¯ï¼‰
            await OnDateChanged.InvokeAsync(null);
        }
        else if (sliderValue >= 0 && sliderValue < MaxSliderValue)
        {
            // åè»¢ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—: sliderValue 0ï¼ˆå·¦ç«¯ï¼‰â†’æœ€å¾Œã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
            var index = MaxSliderValue - 1 - sliderValue;
            if (index >= 0 && index < EditDates.Count)
            {
                var targetDate = EditDates[index];
                await OnDateChanged.InvokeAsync(targetDate);
            }
        }
    }

    /// <summary>
    /// ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ç›®ç››ã‚Šä½ç½®ã‚’è¨ˆç®—
    /// </summary>
    private double GetTickPosition(int index)
    {
        if (MaxSliderValue == 0)
            return 0;
        return (double)index / MaxSliderValue * 100;
    }

    /// <summary>
    /// ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼ã«è¡¨ç¤ºã™ã‚‹ãƒ©ãƒ™ãƒ«ã®ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
    /// </summary>
    private List<SliderLabel> GetSliderLabels()
    {
        var labels = new List<SliderLabel>();

        if (!HasEditDates)
            return labels;

        var totalPositions = MaxSliderValue + 1;

        // è¡¨ç¤ºã™ã‚‹é–“éš”ã‚’è¨ˆç®—
        int interval = 1;

        if (totalPositions > MaxSliderLabels)
        {
            // ç”Ÿæˆã•ã‚Œã‚‹ãƒ©ãƒ™ãƒ«æ•°ãŒMaxSliderLabelsä»¥ä¸‹ã«ãªã‚‹æœ€å°ã®intervalã‚’æ±‚ã‚ã‚‹
            interval = (int)Math.Ceiling((double)MaxSliderValue / (MaxSliderLabels - 1));
        }

        // ç­‰é–“éš”ã«ãƒ©ãƒ™ãƒ«ã‚’é…ç½®
        for (int i = 0; i <= MaxSliderValue; i += interval)
        {
            var position = GetTickPosition(i);
            string text;

            if (i == MaxSliderValue)
            {
                // æœ€æ–°çŠ¶æ…‹ï¼ˆæœ€æ–°ã®ç·¨é›†æ—¥ã‚’è¡¨ç¤ºï¼‰
                text = EditDates!.First().ToString(ShortDateFormat);
            }
            else if (TryGetEditDateAtSliderValue(i, out var date))
            {
                // ç·¨é›†æ—¥
                text = date.ToString(ShortDateFormat);
            }
            else
            {
                // ã“ã“ã«åˆ°é”ã™ã‚‹ã®ã¯æƒ³å®šå¤–ã€‚
                // GetTickPosition ã¯ 0ã€œMaxSliderValue ã®é€£ç¶šå€¤ã‚’å‰æã¨ã—ã¦ãŠã‚Šã€
                // sliderValue < MaxSliderValue ã®ç¯„å›²ã§ã¯å¿…ãšæœ‰åŠ¹ãªç·¨é›†æ—¥ãŒå­˜åœ¨ã™ã‚‹è¨­è¨ˆã§ã‚ã‚‹ã€‚
                Logger.LogWarning(
                    "TryGetEditDateAtSliderValue ãŒæƒ³å®šå¤–ã« false ã‚’è¿”ã—ã¾ã—ãŸã€‚sliderValue={SliderValue}, MaxSliderValue={MaxSliderValue}, EditDatesCount={EditDatesCount}",
                    i, MaxSliderValue, EditDates?.Count);
                continue; // æƒ³å®šå¤–ã ãŒã€UI ã®ç ´ç¶»ã‚’é¿ã‘ã‚‹ãŸã‚å½“è©²ä½ç½®ã®ãƒ©ãƒ™ãƒ«ã¯æç”»ã—ãªã„
            }

            labels.Add(new SliderLabel(position, text, i));
        }

        // æœ€å¾Œã®ä½ç½®ï¼ˆMaxSliderValueï¼‰ãŒãƒ«ãƒ¼ãƒ—ã§å«ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯è¿½åŠ 
        if (MaxSliderValue % interval != 0)
        {
            var position = GetTickPosition(MaxSliderValue);
            var text = EditDates!.First().ToString(ShortDateFormat);
            labels.Add(new SliderLabel(position, text, MaxSliderValue));
        }

        return labels;
    }

    /// <summary>
    /// ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ãƒ©ãƒ™ãƒ«ã®æƒ…å ±
    /// </summary>
    /// <remarks>
    /// SliderValueã¯å°†æ¥çš„ã«ãƒ©ãƒ™ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§å¯¾å¿œã™ã‚‹ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ä½ç½®ã¸ç§»å‹•ã™ã‚‹æ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹éš›ã«ä½¿ç”¨ã™ã‚‹ãŸã‚ä¿æŒã—ã¦ã„ã¾ã™ã€‚
    /// </remarks>
    private record SliderLabel(double Position, string Text, int SliderValue);

    private bool TryGetEditDateAtSliderValue(int sliderValue, out DateTimeOffset date)
    {
        date = default;
        if (sliderValue < 0 || sliderValue >= MaxSliderValue)
            return false;

        var index = MaxSliderValue - 1 - sliderValue;
        if (!IsValidEditDateIndex(index))
            return false;

        date = EditDates[index];
        return true;
    }

    private bool IsValidEditDateIndex(int index)
    {
        return index >= 0 && index < EditDates?.Count;
    }

    protected override void OnParametersSet()
    {
        UpdateCachedData();
        UpdateDisplayMonth();
    }

    /// <summary>
    /// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
    /// </summary>
    private void UpdateCachedData()
    {
        if (HasEditDates)
        {
            _editDatesCache = EditDates!.Select(d => d.Date).ToHashSet();
            _minDate = EditDates!.Min().Date;
            _maxDate = EditDates!.Max().Date;
        }
        else
        {
            _editDatesCache = null;
            _minDate = null;
            _maxDate = null;
        }
        
        // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
        _cachedCalendarDays = null;
    }

    /// <summary>
    /// è¡¨ç¤ºæœˆã‚’æ›´æ–°
    /// </summary>
    private void UpdateDisplayMonth()
    {
        _displayMonth = CurrentDate?.DateTime ?? EditDates?.FirstOrDefault().DateTime ?? DateTime.Now;
    }

    /// <summary>
    /// ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã®é–‹é–‰ã‚’åˆ‡ã‚Šæ›¿ãˆ
    /// </summary>
    private void ToggleCalendarPicker()
    {
        _isCalendarOpen = !_isCalendarOpen;
        if (_isCalendarOpen)
        {
            UpdateDisplayMonth();
        }
    }

    /// <summary>
    /// ãƒ„ãƒ¼ãƒ«ãƒãƒ¼é ˜åŸŸã®ã‚¯ãƒªãƒƒã‚¯ã‚’å‡¦ç†(ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å¤–éƒ¨ã‚¯ãƒªãƒƒã‚¯æ¤œå‡ºç”¨)
    /// </summary>
    private void HandleToolbarClick()
    {
        // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã€ãƒ„ãƒ¼ãƒ«ãƒãƒ¼å†…(ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼å¤–)ã®ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        if (_isCalendarOpen)
        {
            CloseCalendar();
        }
    }

    /// <summary>
    /// ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’é–‰ã˜ã‚‹
    /// </summary>
    private void CloseCalendar()
    {
        _isCalendarOpen = false;
    }

    /// <summary>
    /// å‰æœˆã¸ç§»å‹•
    /// </summary>
    private void PreviousMonth()
    {
        _displayMonth = _displayMonth.AddMonths(-1);
        _cachedCalendarDays = null; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
    }

    /// <summary>
    /// æ¬¡æœˆã¸ç§»å‹•
    /// </summary>
    private void NextMonth()
    {
        _displayMonth = _displayMonth.AddMonths(1);
        _cachedCalendarDays = null; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
    }

    /// <summary>
    /// ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«è¡¨ç¤ºã™ã‚‹æ—¥ä»˜ã®ãƒªã‚¹ãƒˆã‚’å–å¾—
    /// </summary>
    private List<DateTime> GetCalendarDays()
    {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒæœ‰åŠ¹ã§ã€è¡¨ç¤ºæœˆãŒå¤‰ã‚ã£ã¦ã„ãªã„å ´åˆã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’è¿”ã™
        if (_cachedCalendarDays != null && _cachedCalendarMonth == _displayMonth)
        {
            return _cachedCalendarDays;
        }

        var days = new List<DateTime>();
        var firstDayOfMonth = new DateTime(_displayMonth.Year, _displayMonth.Month, 1);

        // æœˆåˆã®æ›œæ—¥ã‚’å–å¾—(æ—¥æ›œæ—¥=0)
        var firstDayOfWeek = (int)firstDayOfMonth.DayOfWeek;

        // å‰æœˆã®æ—¥ä»˜ã‚’è¿½åŠ (æœˆåˆãŒæ—¥æ›œæ—¥ã§ãªã„å ´åˆ)
        var startDate = firstDayOfMonth.AddDays(-firstDayOfWeek);

        // 6é€±é–“åˆ†(42æ—¥)è¡¨ç¤º
        for (int i = 0; i < 42; i++)
        {
            days.Add(startDate.AddDays(i));
        }

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
        _cachedCalendarDays = days;
        _cachedCalendarMonth = _displayMonth;

        return days;
    }

    /// <summary>
    /// æ—¥ä»˜ãŒé¸æŠå¯èƒ½ã‹ã©ã†ã‹(æœ€å°æ—¥ä»˜ã‹ã‚‰æœ€å¤§æ—¥ä»˜ã®ç¯„å›²å†…)
    /// </summary>
    private bool IsDateSelectable(DateTime date)
    {
        if (!HasEditDates || _minDate == null || _maxDate == null)
            return false;

        // æœ€å°æ—¥ä»˜ã‹ã‚‰æœ€å¤§æ—¥ä»˜ã®ç¯„å›²å†…ã§ã‚ã‚Œã°é¸æŠå¯èƒ½
        return date.Date >= _minDate.Value && date.Date <= _maxDate.Value;
    }

    /// <summary>
    /// EditDatesã«å«ã¾ã‚Œã‚‹æ—¥ä»˜ã‹ã©ã†ã‹
    /// </summary>
    private bool IsEditDate(DateTime date)
    {
        if (_editDatesCache == null)
            return false;

        return _editDatesCache.Contains(date.Date);
    }

    /// <summary>
    /// æ—¥ä»˜ã®CSSã‚¯ãƒ©ã‚¹ã‚’å–å¾—
    /// </summary>
    private string GetDayClass(DateTime date)
    {
        var classes = new List<string>();

        // å½“æœˆä»¥å¤–ã®æ—¥ä»˜
        if (date.Month != _displayMonth.Month)
        {
            classes.Add("other-month");
        }

        // EditDatesã«å«ã¾ã‚Œã‚‹æ—¥ä»˜
        if (IsEditDate(date))
        {
            classes.Add("edit-date");
        }

        // é¸æŠä¸­ã®æ—¥ä»˜
        if (CurrentDate.HasValue && date.Date == CurrentDate.Value.Date)
        {
            classes.Add("selected");
        }

        // ä»Šæ—¥
        if (date.Date == DateTime.Today)
        {
            classes.Add("today");
        }

        return string.Join(" ", classes);
    }

    /// <summary>
    /// æ—¥ä»˜ã®aria-labelã‚’å–å¾—
    /// </summary>
    private string GetDayAriaLabel(DateTime date)
    {
        var label = date.ToString("Mæœˆdæ—¥");
        
        if (IsEditDate(date))
        {
            label += " (ç·¨é›†æ—¥)";
        }
        
        if (CurrentDate.HasValue && date.Date == CurrentDate.Value.Date)
        {
            label += " é¸æŠä¸­";
        }
        
        return label;
    }

    /// <summary>
    /// æ—¥ä»˜ã‚’é¸æŠ
    /// </summary>
    private async Task SelectDate(DateTime date)
    {
        if (!IsDateSelectable(date))
            return;

        // EditDatesã«å«ã¾ã‚Œã‚‹æ—¥ä»˜ã‹ç¢ºèª
        var matchingDate = EditDates!.FirstOrDefault(d => d.Date == date.Date);

        if (matchingDate != default(DateTimeOffset))
        {
            // EditDatesã«å«ã¾ã‚Œã‚‹æ—¥ä»˜ã®å ´åˆ
            await OnDateChanged.InvokeAsync(matchingDate);
        }
        else
        {
            // EditDatesã«å«ã¾ã‚Œã¦ã„ãªã„æ—¥ä»˜ã®å ´åˆã€æœ€ã‚‚è¿‘ã„æ—¥ä»˜ã‚’æ¢ã™
            var closestDate = EditDates!
                .OrderBy(d => Math.Abs((d.Date - date.Date).TotalDays))
                .First();

            Logger.LogInformation(
                "é¸æŠã•ã‚ŒãŸæ—¥ä»˜ {SelectedDate} ã¯EditDatesã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æœ€ã‚‚è¿‘ã„æ—¥ä»˜ {ClosestDate} ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚",
                date, closestDate);

            await OnDateChanged.InvokeAsync(closestDate);
        }

        _isCalendarOpen = false; // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’é–‰ã˜ã‚‹
    }
}
