<div class="timeline-toolbar @(IsViewingPast ? "viewing-past" : "")">
    <button
        class="timeline-btn timeline-btn-prev"
        @onclick="MoveToPrevious"
        disabled="@(!CanMoveToPrevious)"
        title="前の編集日へ"
        type="button">
        ◀
    </button>

    <div class="timeline-info">
        @if (CurrentDate.HasValue)
        {
            <span class="timeline-date">@CurrentDate.Value.ToString("yyyy/MM/dd")</span>
            <span class="timeline-badge">過去の状態</span>
        }
        else
        {
            <span class="timeline-date">最新</span>
            <span class="timeline-badge badge-live">現在の状態</span>
        }
    </div>

    <button
        class="timeline-btn timeline-btn-next"
        @onclick="MoveToNext"
        disabled="@(!CanMoveToNext)"
        title="次の編集日へ"
        type="button">
        ▶
    </button>

    @if (IsViewingPast)
    {
        <button
            class="timeline-btn timeline-btn-reset"
            @onclick="MoveToLatest"
            title="最新状態に戻る"
            type="button">
            最新に戻る
        </button>
    }
</div>

@* スライドバーコントロール *@
@if (EditDates != null && EditDates.Count > 0)
{
    <div class="timeline-slider-container">
        <div class="timeline-slider-labels">
            @* TODO: 日付で表現する *@
            <span class="slider-label slider-label-start">最古</span>
            <span class="slider-label slider-label-center">@GetCenterDateLabel()</span>
            <span class="slider-label slider-label-end">最新</span>
        </div>
        <input
            type="range"
            class="timeline-slider"
            min="0"
            max="@MaxSliderValue"
            value="@CurrentSliderValue"
            @onchange="HandleSliderChange"
            aria-label="日付スライダー"
            title="@GetSliderTooltip()" />
        <div class="timeline-slider-ticks">
            @for (int i = 0; i <= MaxSliderValue; i++)
            {
                <div class="slider-tick @(i == CurrentSliderValue ? "active" : "")" 
                     style="left: @(GetTickPosition(i))%"></div>
            }
        </div>
    </div>
}

@code {
    /// <summary>
    /// 現在表示中の日付（nullの場合は最新）
    /// </summary>
    [Parameter]
    public DateTimeOffset? CurrentDate { get; set; }

    /// <summary>
    /// 編集日一覧（降順：新しい順）
    /// </summary>
    [Parameter]
    public List<DateTimeOffset> EditDates { get; set; } = new();

    /// <summary>
    /// 日付変更イベント
    /// </summary>
    [Parameter]
    public EventCallback<DateTimeOffset?> OnDateChanged { get; set; }

    /// <summary>
    /// 過去を表示中かどうか
    /// </summary>
    private bool IsViewingPast => CurrentDate.HasValue;

    /// <summary>
    /// スライドバーの最大値（0が最古、MaxSliderValueが最新）
    /// </summary>
    private int MaxSliderValue => EditDates?.Count ?? 0;

    /// <summary>
    /// 現在のスライドバーの値
    /// </summary>
    private int CurrentSliderValue
    {
        get
        {
            if (!CurrentDate.HasValue)
                return MaxSliderValue; // 最新（右端）

            // EditDatesリストでのインデックスを検索（降順リストなので反転）
            var index = EditDates?.FindIndex(d => d.Date == CurrentDate.Value.Date) ?? -1;
            if (index >= 0)
            {
                // 反転: 0番目（最新の編集日）→MaxSliderValue-1、最後（最古）→0
                return MaxSliderValue - 1 - index;
            }
            return MaxSliderValue; // 見つからない場合は最新
        }
    }

    private const string LiveStateLabel = "最新の状態";
    private const string DateFormat = "yyyy/MM/dd";
    private const string ShortDateFormat = "MM/dd";

    /// <summary>
    /// 前の編集日へ移動可能かどうか
    /// </summary>
    private bool CanMoveToPrevious
    {
        get
        {
            if (!HasEditDates)
                return false;

            if (IsViewingLatest)
                return EditDates.Count > 0;

            return HasOlderDates();
        }
    }

    /// <summary>
    /// 次の編集日へ移動可能かどうか
    /// </summary>
    private bool CanMoveToNext => IsViewingPast;

    private bool HasEditDates => EditDates != null && EditDates.Count > 0;
    private bool IsViewingLatest => !CurrentDate.HasValue;
    private bool HasOlderDates() => EditDates.Any(d => d < CurrentDate!.Value);

    /// <summary>
    /// 前の編集日（より古い日付）へ移動
    /// </summary>
    private async Task MoveToPrevious()
    {
        if (!CanMoveToPrevious)
            return;

        DateTimeOffset? newDate;

        if (!CurrentDate.HasValue)
        {
            // 最新表示中の場合、最新の編集日（リストの先頭）へ
            newDate = EditDates.FirstOrDefault();
        }
        else
        {
            // 現在の日付より古い日付のうち、最も新しいものを取得
            newDate = EditDates
                .Where(d => d < CurrentDate.Value)
                .OrderByDescending(d => d)
                .FirstOrDefault();
        }

        if (newDate != default(DateTimeOffset))
        {
            await OnDateChanged.InvokeAsync(newDate);
        }
    }

    /// <summary>
    /// 次の編集日（より新しい日付）へ移動。最新の編集日より後は「最新状態」に戻る。
    /// </summary>
    private async Task MoveToNext()
    {
        if (!CanMoveToNext)
            return;

        var newDate = EditDates
            .Where(d => d > CurrentDate!.Value)
            .OrderBy(d => d)
            .FirstOrDefault();

        // もし新しい日付がなければ（＝現在が最新の過去スナップショット）、
        // または見つからなければ、最新状態(null)に戻る
        if (newDate == default(DateTimeOffset))
        {
            await MoveToLatest();
        }
        else
        {
            await OnDateChanged.InvokeAsync(newDate);
        }
    }

    /// <summary>
    /// 最新状態に戻る
    /// </summary>
    private async Task MoveToLatest()
    {
        await OnDateChanged.InvokeAsync(null);
    }

    /// <summary>
    /// スライドバーの変更完了イベント（マウスアップ時）
    /// </summary>
    private async Task HandleSliderChange(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            await MoveToSliderValue(value);
        }
    }

    /// <summary>
    /// スライダー値に対応する日付へ移動
    /// </summary>
    private async Task MoveToSliderValue(int sliderValue)
    {
        if (sliderValue == MaxSliderValue)
        {
            // 最新状態（右端）
            await OnDateChanged.InvokeAsync(null);
        }
        else if (sliderValue >= 0 && sliderValue < MaxSliderValue)
        {
            // 反転してインデックスを計算: sliderValue 0（左端）→最後のインデックス
            var index = MaxSliderValue - 1 - sliderValue;
            if (index >= 0 && index < EditDates.Count)
            {
                var targetDate = EditDates[index];
                await OnDateChanged.InvokeAsync(targetDate);
            }
        }
    }

    /// <summary>
    /// スライダーの目盛り位置を計算
    /// </summary>
    private double GetTickPosition(int index)
    {
        if (MaxSliderValue == 0)
            return 0;
        return (double)index / MaxSliderValue * 100;
    }

    /// <summary>
    /// スライダーのツールチップテキスト
    /// </summary>
    private string GetSliderTooltip()
    {
        if (CurrentSliderValue == MaxSliderValue)
            return LiveStateLabel;

        if (TryGetEditDateAtSliderValue(CurrentSliderValue, out var date))
        {
            return date.ToString(DateFormat);
        }

        return string.Empty;
    }

    /// <summary>
    /// スライダー中央のラベルを取得
    /// </summary>
    private string GetCenterDateLabel()
    {
        if (!HasEditDates)
            return string.Empty;

        var middleIndex = EditDates.Count / 2;
        return IsValidEditDateIndex(middleIndex) 
            ? EditDates[middleIndex].ToString(ShortDateFormat) 
            : string.Empty;
    }

    private bool TryGetEditDateAtSliderValue(int sliderValue, out DateTimeOffset date)
    {
        date = default;
        if (sliderValue < 0 || sliderValue >= MaxSliderValue)
            return false;

        var index = MaxSliderValue - 1 - sliderValue;
        if (!IsValidEditDateIndex(index))
            return false;

        date = EditDates[index];
        return true;
    }

    private bool IsValidEditDateIndex(int index)
    {
        return index >= 0 && index < EditDates?.Count;
    }
}
