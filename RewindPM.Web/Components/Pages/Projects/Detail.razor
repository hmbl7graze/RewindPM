@page "/projects/{id:guid}"
@rendermode InteractiveServer
@using MediatR
@using RewindPM.Application.Read.Queries.Projects
@using RewindPM.Application.Read.Queries.Tasks
@using RewindPM.Application.Read.DTOs
@using RewindPM.Application.Write.Commands.Tasks
@using RewindPM.Web.Components.Pages.Tasks
@using RewindPM.Web.Components.Tasks
@using RewindPM.Web.Components.Shared
@using RewindPM.Web.Components.Statistics
@using TaskStatus = RewindPM.Domain.ValueObjects.TaskStatus
@inject IMediator Mediator
@inject NavigationManager Navigation
@inject ILogger<Detail> Logger

<PageTitle>@(project?.Title ?? "プロジェクト詳細") - RewindPM</PageTitle>

@if (isLoading)
{
    <div class="loading-state">
        <p><em>読み込み中...</em></p>
    </div>
}
else if (project == null)
{
    <div class="alert alert-danger">プロジェクトが見つかりません。</div>
    <a href="/projects" class="btn btn-secondary">プロジェクト一覧に戻る</a>
}
else
{
    <!-- ヘッダー部 -->
    <div class="project-detail-header">
        <div class="header-left">
            <a href="/projects" class="back-link">← Back to Projects</a>
        </div>
        <div class="header-center">
            <h1 class="project-title">
                @project.Title
                <a href="/projects/@Id/edit" class="btn-icon header-edit-btn" title="Edit Project">
                    Edit
                </a>
            </h1>
        </div>
        <div class="header-right">
            <button class="btn @(_isRetrospectiveMode ? "btn-primary" : "btn-outline-secondary")" @onclick="ToggleRetrospectiveMode">
                Retrospective
            </button>
        </div>
    </div>

    <!-- プロジェクト情報表示 -->
    <div class="project-info">
        @if (!string.IsNullOrWhiteSpace(project.Description))
        {
            <div class="project-description">
                <strong>Description:</strong>
                <p>@project.Description</p>
            </div>
        }
    </div>

    <!-- タイムラインコントロール(リワインド機能) - 振り返りモード時のみ表示 -->
    @if (_isRetrospectiveMode)
    {
        <div class="retrospective-panel">
            <TimelineControl
                CurrentDate="_currentViewDate"
                EditDates="_editDates"
                OnDateChanged="HandleDateChanged" />
        </div>
    }

    <!-- タスクビュー表示エリア -->
    <div class="tasks-section">
        <div class="view-header">
            <div class="view-tabs">
                <button class="view-tab @(_viewType == "Gantt" ? "active" : "")" @onclick='() => ToggleView("Gantt")'>Gantt Chart</button>
                <button class="view-tab @(_viewType == "Kanban" ? "active" : "")" @onclick='() => ToggleView("Kanban")'>Kanban</button>
                <button class="view-tab @(_viewType == "Statistics" ? "active" : "")" @onclick='() => ToggleView("Statistics")'>Statistics</button>
            </div>
            <div class="view-actions">
                <button class="btn btn-success" @onclick="ShowCreateTaskModal" disabled="@_isViewingPast">Add Task</button>
            </div>
        </div>

        <div class="view-container">
            @if (_viewType == "Gantt")
            {
                @if (isLoadingTasks)
                {
                    <div class="loading-overlay">
                        <p><em>タスクを読み込み中...</em></p>
                    </div>
                }
                else
                {
                    <GanttChart @key="_ganttChartKey"
                                Tasks="@(tasks ?? new List<TaskDto>())"
                                OnTaskClick="ShowTaskDetailModal"
                                OnBarResize="HandleBarResize"
                                ViewDate="_currentViewDate"
                                IsReadOnly="_isViewingPast" />
                }
            }
            else if (_viewType == "Statistics")
            {
                <ProjectStatisticsDashboard ProjectId="@Id" AsOfDate="@(_isRetrospectiveMode ? _currentViewDate : null)" />
            }
            else
            {
                @if (isLoadingTasks)
                {
                    <div class="loading-overlay">
                        <p><em>タスクを読み込み中...</em></p>
                    </div>
                }
                else
                {
                    <KanbanBoard Tasks="@(tasks ?? new List<TaskDto>())"
                                 OnTaskClick="ShowTaskDetailModal"
                                 OnTaskStatusChanged="HandleTaskStatusChanged"
                                 IsReadOnly="_isViewingPast" />
                }
            }
        </div>
    </div>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger mt-3">@errorMessage</div>
    }

    <!-- タスク作成・編集モーダル -->
    <TaskFormModal @bind-IsVisible="showTaskModal"
                   ProjectId="@Id"
                   ExistingTask="@selectedTask"
                   OnSuccess="HandleTaskModalSuccess"
                   OnCancel="HandleTaskModalCancel"
                   IsReadOnly="_isViewingPast" />
}

@code {
    private const string DefaultUserId = "system";
    private const string GanttViewType = "Gantt";
    private const string KanbanViewType = "Kanban";
    private const string StatisticsViewType = "Statistics";

    [Parameter]
    public Guid Id { get; set; }

    // データ状態
    private ProjectDto? project;
    private List<TaskDto>? tasks;
    private List<DateTime> _editDates = new();

    // UI状態
    private bool isLoading = true;
    private bool isLoadingTasks = true;
    private string? errorMessage;
    private bool showTaskModal = false;
    private TaskDto? selectedTask = null;

    // ビュー状態
    private string _viewType = GanttViewType;
    private int _ganttChartKey = 0;

    // リワインド状態
    private DateTime? _currentViewDate = null;
    private bool _isRetrospectiveMode = false;
    
    private bool _isViewingPast => _currentViewDate.HasValue;

    private void ToggleView(string viewType)
    {
        _viewType = viewType;
    }

    private async Task HandleTaskStatusChanged((TaskDto task, TaskStatus newStatus) changeData)
    {
        if (_isViewingPast) 
            return;

        try
        {
            await UpdateTaskStatus(changeData);
            await ReloadTaskData();
        }
        catch (Exception ex)
        {
            LogAndDisplayError(ex, "タスクのステータス更新に失敗しました", changeData.task.Id);
        }
    }

    private async Task UpdateTaskStatus((TaskDto task, TaskStatus newStatus) changeData)
    {
        var command = new ChangeTaskStatusCommand(
            TaskId: changeData.task.Id,
            NewStatus: changeData.newStatus,
            ChangedBy: DefaultUserId
        );

        await Mediator.Send(command);
    }

    private async Task ReloadTaskData()
    {
        await LoadTasks();
        await LoadEditDates();
        StateHasChanged();
    }

    private void LogAndDisplayError(Exception ex, string message, Guid? taskId = null)
    {
        if (taskId.HasValue)
        {
            Logger.LogError(ex, "{Message} for task {TaskId}", message, taskId.Value);
        }
        else
        {
            Logger.LogError(ex, message);
        }
        errorMessage = "操作に失敗しました。もう一度お試しください。";
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadProject();
        await LoadEditDates();
        await LoadTasks();
    }

    /// <summary>
    /// 編集日一覧を取得
    /// </summary>
    private async Task LoadEditDates()
    {
        try
        {
            var query = new GetProjectEditDatesQuery(Id, Ascending: false);
            _editDates = await Mediator.Send(query);
        }
        catch (Exception ex)
        {
            errorMessage = $"編集日一覧の読み込みに失敗しました: {ex.Message}";
            _editDates = new List<DateTime>();
        }
    }

    private async Task LoadProject()
    {
        try
        {
            var query = new GetProjectByIdQuery(Id);
            project = await Mediator.Send(query);
        }
        catch (Exception ex)
        {
            errorMessage = $"プロジェクトの読み込みに失敗しました: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task LoadTasks()
    {
        try
        {
            isLoadingTasks = true;
            tasks = _isViewingPast 
                ? await LoadTasksAtTime(_currentViewDate!.Value)
                : await LoadLatestTasks();
        }
        catch (Exception ex)
        {
            HandleTaskLoadError(ex);
        }
        finally
        {
            isLoadingTasks = false;
        }
    }

    private async Task<List<TaskDto>> LoadTasksAtTime(DateTime date)
    {
        var query = new GetTasksByProjectIdAtTimeQuery(Id, date);
        return await Mediator.Send(query);
    }

    private async Task<List<TaskDto>> LoadLatestTasks()
    {
        var query = new GetTasksByProjectIdQuery(Id);
        return await Mediator.Send(query);
    }

    private void HandleTaskLoadError(Exception ex)
    {
        errorMessage = $"タスクの読み込みに失敗しました: {ex.Message}";
        tasks = new List<TaskDto>();
    }

    private void ShowCreateTaskModal()
    {
        if (_isViewingPast)
        {
            errorMessage = "過去の状態を表示中のため、タスクを作成できません。";
            return;
        }

        selectedTask = null;
        showTaskModal = true;
    }

    private void ShowTaskDetailModal(TaskDto task)
    {
        selectedTask = task;
        showTaskModal = true;
    }

    private async Task HandleTaskModalSuccess()
    {
        CloseTaskModal();
        await ReloadTaskData();
    }

    private void HandleTaskModalCancel()
    {
        CloseTaskModal();
    }

    private void CloseTaskModal()
    {
        showTaskModal = false;
        selectedTask = null;
    }

    /// <summary>
    /// タイムラインコントロールで日付が変更された際の処理
    /// </summary>
    private async Task HandleDateChanged(DateTime? newDate)
    {
        _currentViewDate = newDate;
        await LoadTasks();
        RefreshGanttChart();
    }

    private void RefreshGanttChart()
    {
        _ganttChartKey++;
        StateHasChanged();
    }

    private async Task HandleBarResize((Guid taskId, string barType, DateTime newStartDate, DateTime newEndDate) resizeData)
    {
        if (_isViewingPast)
        {
            errorMessage = "過去の状態を表示中のため、編集できません。";
            return;
        }

        try
        {
            var task = FindTaskById(resizeData.taskId);
            if (task == null) return;

            await UpdateTaskPeriod(task, resizeData);
            await ReloadTaskData();
        }
        catch (Exception ex)
        {
            LogAndDisplayError(ex, "タスクの期間更新に失敗しました", resizeData.taskId);
        }
    }

    private TaskDto? FindTaskById(Guid taskId)
    {
        return tasks?.FirstOrDefault(t => t.Id == taskId);
    }

    private async Task UpdateTaskPeriod(TaskDto task, (Guid taskId, string barType, DateTime newStartDate, DateTime newEndDate) resizeData)
    {
        if (resizeData.barType == "scheduled")
        {
            await UpdateScheduledPeriod(task, resizeData.newStartDate, resizeData.newEndDate);
        }
        else if (resizeData.barType == "actual")
        {
            await UpdateActualPeriod(task, resizeData.newStartDate, resizeData.newEndDate);
        }
    }

    private async Task UpdateScheduledPeriod(TaskDto task, DateTime newStartDate, DateTime newEndDate)
    {
        var command = new ChangeTaskScheduleCommand(
            TaskId: task.Id,
            ScheduledStartDate: newStartDate,
            ScheduledEndDate: newEndDate,
            EstimatedHours: task.EstimatedHours ?? 0,
            ChangedBy: DefaultUserId
        );
        await Mediator.Send(command);
    }

    private async Task UpdateActualPeriod(TaskDto task, DateTime newStartDate, DateTime newEndDate)
    {
        var command = new ChangeTaskActualPeriodCommand(
            TaskId: task.Id,
            ActualStartDate: newStartDate,
            ActualEndDate: newEndDate,
            ActualHours: task.ActualHours,
            ChangedBy: DefaultUserId
        );
        await Mediator.Send(command);
    }

    private async Task ToggleRetrospectiveMode()
    {
        _isRetrospectiveMode = !_isRetrospectiveMode;
        
        if (ShouldReturnToLatestState())
        {
            await ReturnToLatestState();
        }
    }

    private bool ShouldReturnToLatestState()
    {
        return !_isRetrospectiveMode && _isViewingPast;
    }

    private async Task ReturnToLatestState()
    {
        _currentViewDate = null;
        await LoadTasks();
    }

    /// <summary>
    /// 現在のユーザーIDを取得（未実装）
    /// </summary>
    private string GetCurrentUserId()
    {
        // TODO: 認証サービスから実際のユーザーIDを取得する
        return DefaultUserId;
    }
}
