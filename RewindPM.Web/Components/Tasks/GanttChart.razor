@using RewindPM.Application.Read.DTOs
@using TaskStatus = RewindPM.Domain.ValueObjects.TaskStatus
@using Microsoft.JSInterop
@using RewindPM.Web.Components.Shared
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="gantt-chart @(IsReadOnly ? "readonly-mode" : "")">
    @if (Tasks == null || !Tasks.Any())
    {
        <div class="gantt-empty">
            <p>タスクがありません</p>
        </div>
    }
    else if (TimelineStart == null || TimelineEnd == null)
    {
        <div class="gantt-empty">
            <p>予定期間が設定されたタスクがありません</p>
        </div>
    }
    else
    {
        <div class="gantt-scroll-container" style="@(scriptsInitialized ? "" : "visibility: hidden;")">
            @* Zoom Toolbar - Floating at top-right *@
            <div class="gantt-zoom-toolbar">
                <button class="gantt-zoom-btn gantt-zoom-fit" @onclick="FitToScreen" title="全体を表示">
                    全体を表示
                </button>
                <div class="gantt-zoom-group">
                    <span class="gantt-zoom-label">横:</span>
                    <button class="gantt-zoom-btn" @onclick="ZoomOutHorizontal" disabled="@(!CanZoomOutHorizontal)" title="横方向縮小">
                        −
                    </button>
                    <button class="gantt-zoom-btn" @onclick="ZoomInHorizontal" disabled="@(!CanZoomInHorizontal)" title="横方向拡大">
                        +
                    </button>
                </div>
                <div class="gantt-zoom-group">
                    <span class="gantt-zoom-label">縦:</span>
                    <button class="gantt-zoom-btn" @onclick="ZoomOutVertical" disabled="@(!CanZoomOutVertical)" title="縦方向縮小">
                        −
                    </button>
                    <button class="gantt-zoom-btn" @onclick="ZoomInVertical" disabled="@(!CanZoomInVertical)" title="縦方向拡大">
                        +
                    </button>
                </div>
            </div>
            @* Header Row *@
            <div class="gantt-row gantt-header-row">
                <div class="gantt-cell gantt-sticky-left gantt-header-corner">タスク名</div>
                <div class="gantt-timeline-area">
                    @* Month Row *@
                    <div class="gantt-timeline-subrow">
                        <div class="gantt-timeline-grid" style="grid-template-columns: @GetGridTemplateColumns();">
                            @foreach (var monthGroup in GetMonthGroups())
                            {
                                <div class="gantt-month-cell" style="grid-column: @monthGroup.StartColumn / @monthGroup.EndColumn;">
                                    @monthGroup.Year/@monthGroup.Month
                                </div>
                            }
                        </div>
                    </div>
                    @* Date Row *@
                    <div class="gantt-timeline-subrow">
                        <div class="gantt-timeline-grid" style="grid-template-columns: @GetGridTemplateColumns();">
                            @for (int i = 0; i < TotalDays; i++)
                            {
                                var date = TimelineStart.Value.AddDays(i);
                                <div class="gantt-date-cell">
                                    @if (ShouldDisplayDateLabel(i))
                                    {
                                        <div class="gantt-date-label">@date.Day</div>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>

            @* Task Rows *@
            @foreach (var (task, index) in Tasks.Select((t, i) => (t, i)))
            {
                <div class="gantt-row gantt-task-row">
                    <div class="gantt-cell gantt-sticky-left gantt-task-name-cell" style="@GetRowHeightStyle()" title="@task.Title" @onclick="() => HandleTaskClick(task)">
                        <span class="gantt-task-title">@task.Title</span>
                        <span class="gantt-task-status gantt-status-@GetStatusClass(task.Status)" style="@GetStatusBadgeStyle()">
                            @GetStatusLabel(task.Status)
                        </span>
                    </div>
                    <div class="gantt-timeline-area" style="@GetRowHeightStyle()">
                        <div class="gantt-timeline-grid" style="grid-template-columns: @GetGridTemplateColumns();">
                            @* Scheduled Bar *@
                            @if (ShouldDisplayBar(task.Id, "scheduled"))
                            {
                                var barState = GetDisplayBarState(task.Id, "scheduled");
                                if (barState != null)
                                {
                                    var gridColumn = GetGridColumn(barState.StartDate, barState.EndDate);
                                    var animationClass = GetBarAnimationClass(task.Id, "scheduled");
                                    <div class="gantt-bar gantt-bar-scheduled @animationClass"
                                         style="grid-column: @gridColumn; @GetBarMarginStyle("scheduled")"
                                         title="予定: @barState.StartDate.ToString("yyyy/MM/dd") - @barState.EndDate.ToString("yyyy/MM/dd")"
                                         data-task-id="@task.Id"
                                         data-bar-type="scheduled">
                                        @if (!IsReadOnly && string.IsNullOrEmpty(animationClass))
                                        {
                                            <div class="gantt-resize-handle gantt-resize-handle-left"></div>
                                            <div class="gantt-resize-handle gantt-resize-handle-right"></div>
                                        }
                                    </div>
                                }
                            }

                            @* Actual Bar *@
                            @if (ShouldDisplayBar(task.Id, "actual"))
                            {
                                var barState = GetDisplayBarState(task.Id, "actual");
                                if (barState != null)
                                {
                                    var gridColumn = GetGridColumn(barState.StartDate, barState.EndDate);
                                    var animationClass = GetBarAnimationClass(task.Id, "actual");
                                    <div class="gantt-bar gantt-bar-actual @animationClass"
                                         style="grid-column: @gridColumn; @GetBarMarginStyle("actual")"
                                         title="実績: @barState.StartDate.ToString("yyyy/MM/dd") - @barState.EndDate.ToString("yyyy/MM/dd")"
                                         data-task-id="@task.Id"
                                         data-bar-type="actual">
                                        @if (!IsReadOnly && string.IsNullOrEmpty(animationClass))
                                        {
                                            <div class="gantt-resize-handle gantt-resize-handle-left"></div>
                                            <div class="gantt-resize-handle gantt-resize-handle-right"></div>
                                        }
                                    </div>
                                }
                            }
                        </div>
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter]
    public List<TaskDto> Tasks { get; set; } = new();

    [Parameter]
    public EventCallback<TaskDto> OnTaskClick { get; set; }

    [Parameter]
    public EventCallback<(Guid taskId, string barType, DateTimeOffset newStartDate, DateTimeOffset newEndDate)> OnBarResize { get; set; }

    [Parameter]
    public DateTimeOffset? ViewDate { get; set; }

    [Parameter]
    public bool IsReadOnly { get; set; } = false;

    [Parameter]
    public EventCallback<double> OnZoomChanged { get; set; }

    private DateTime? TimelineStart { get; set; }
    private DateTime? TimelineEnd { get; set; }
    private int TotalDays { get; set; }

    // 前回のタイムライン範囲を保持（ズーム保持のため）
    private DateTime? previousTimelineStart;
    private DateTime? previousTimelineEnd;
    private int previousTotalDays;

    // ズーム機能関連
    private double horizontalZoomScale = 1.0; // 横方向ズーム 100%
    private double verticalZoomScale = 1.0; // 縦方向ズーム 100%
    private double baseColumnWidth = 40.0; // 基準セル幅（横方向）
    private double baseRowHeight = 48.0; // 基準行高さ（縦方向）
    private double availableTimelineWidth = 0;
    private double availableTimelineHeight = 0;
    private static readonly double[] ZoomLevels = { 1.0, 1.5, 2.0, 3.0, 4.0 };
    private int horizontalZoomLevelIndex = 0; // 横方向ズームレベル (初期値: 100%)
    private int verticalZoomLevelIndex = 0; // 縦方向ズームレベル (初期値: 100%)
    
    // Initial Zoom Calculation Flags
    private bool _isBaseColumnWidthCalculated = false;
    private bool _isBaseRowHeightCalculated = false;

    private DotNetObjectReference<GanttChart>? dotNetRef;
    private bool scriptsInitialized = false;

    // 前回のバー状態を保持（アニメーション判定用）
    private Dictionary<string, BarState> previousBarStates = new();
    private HashSet<string> barsToAnimate = new();
    private readonly HashSet<string> fadingOutBars = new();
    private Dictionary<string, BarState> displayBarStates = new();

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        if (IsInitialLoad())
        {
            InitializeBarStates();
            InitializeDisplayBarStates();
        }
        else
        {
            await HandleBarsChanged();
        }

        CalculateTimeline();
    }

    private bool IsInitialLoad() => previousBarStates.Count == 0;

    private void InitializeBarStates()
    {
        if (Tasks == null) return;

        foreach (var task in Tasks)
        {
            if (task.ScheduledStartDate.HasValue && task.ScheduledEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "scheduled");
                previousBarStates[key] = new BarState(task.ScheduledStartDate.Value, task.ScheduledEndDate.Value);
            }

            if (task.ActualStartDate.HasValue && task.ActualEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "actual");
                previousBarStates[key] = new BarState(task.ActualStartDate.Value, task.ActualEndDate.Value);
            }
        }
    }

    private void InitializeDisplayBarStates()
    {
        displayBarStates = previousBarStates.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    private async Task HandleBarsChanged()
    {
        var currentBarStates = GetCurrentBarStates();
        var removedBars = GetRemovedBars(currentBarStates);

        if (removedBars.Any())
        {
            await AnimateBarRemoval(removedBars);
        }
        else
        {
            DetectChanges();
            UpdateDisplayBarStates();
        }

        previousBarStates = currentBarStates;
    }

    private Dictionary<string, BarState> GetCurrentBarStates()
    {
        var currentBarStates = new Dictionary<string, BarState>();
        if (Tasks == null) return currentBarStates;

        foreach (var task in Tasks)
        {
            if (task.ScheduledStartDate.HasValue && task.ScheduledEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "scheduled");
                currentBarStates[key] = new BarState(task.ScheduledStartDate.Value, task.ScheduledEndDate.Value);
            }

            if (task.ActualStartDate.HasValue && task.ActualEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "actual");
                currentBarStates[key] = new BarState(task.ActualStartDate.Value, task.ActualEndDate.Value);
            }
        }

        return currentBarStates;
    }

    private List<string> GetRemovedBars(Dictionary<string, BarState> currentBarStates)
    {
        return previousBarStates.Keys
            .Where(key => !currentBarStates.ContainsKey(key))
            .ToList();
    }

    private async Task AnimateBarRemoval(List<string> removedBars)
    {
        // フェードアウト対象をマーク
        foreach (var barKey in removedBars)
        {
            fadingOutBars.Add(barKey);
        }

        // 表示バーは前回の状態を維持（削除されるバーも表示し続ける）
        displayBarStates = previousBarStates.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

        // 変更検出も実行（他のバーの変更を検出）
        DetectChanges();

        StateHasChanged();

        // アニメーション期間待機
        await Task.Delay(AnimationConstants.FadeOutDurationMs);

        // フェードアウト完了後、実際に削除
        fadingOutBars.Clear();
        UpdateDisplayBarStates();
    }

    private void UpdateDisplayBarStates()
    {
        displayBarStates = GetCurrentBarStates();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || !scriptsInitialized)
        {
            try
            {
                // ローカルストレージからズームレベルを復元
                await LoadZoomLevelsFromStorage();

                dotNetRef = DotNetObjectReference.Create(this);
                // Only initialize resize handles and pass dotnet ref for callbacks
                await JSRuntime.InvokeVoidAsync("ganttScrollSync.initialize", dotNetRef);

                // 画面の幅と高さを取得して基準セル幅・行高さを計算
                availableTimelineWidth = await JSRuntime.InvokeAsync<double>("ganttZoom.getAvailableWidth");
                availableTimelineHeight = await JSRuntime.InvokeAsync<double>("ganttZoom.getAvailableHeight");
                CalculateBaseColumnWidth();
                CalculateBaseRowHeight();

                // ツールバーのドラッグ機能を初期化
                await JSRuntime.InvokeVoidAsync("ganttZoom.initializeDraggableToolbar");

                scriptsInitialized = true;
                
                // 初期表示のズーム状態を正しく反映するために再レンダリングする
                // これがないと初期表示時に計算された幅が反映されず、最初の操作で表示が飛ぶ現象が発生する
                StateHasChanged();
            }
            catch (Exception ex)
            {
                // JavaScript初期化エラーをログに記録
                Console.Error.WriteLine($"ガントチャートの初期化エラー: {ex.Message}");
            }
        }
        else
        {
            try
            {
                // 再レンダリング後にリサイズハンドルを再初期化
                await JSRuntime.InvokeVoidAsync("ganttScrollSync.reinitializeResizeHandles");
            }
            catch (Exception ex)
            {
                // JavaScript再初期化エラーをログに記録
                Console.Error.WriteLine($"リサイズハンドルの再初期化エラー: {ex.Message}");
            }
        }
    }

    [JSInvokable]
    public async Task OnBarResized(string taskIdStr, string barType, int startDayIndex, int endDayIndex)
    {
        if (TimelineStart == null) return;

        if (!Guid.TryParse(taskIdStr, out var taskId)) return;

        // インデックスから日付を計算（UTC offsetで統一）
        var newStartDate = new DateTimeOffset(TimelineStart.Value.AddDays(startDayIndex), TimeSpan.Zero);
        var newEndDate = new DateTimeOffset(TimelineStart.Value.AddDays(endDayIndex), TimeSpan.Zero);

        // コールバックを呼び出し
        if (OnBarResize.HasDelegate)
        {
            await OnBarResize.InvokeAsync((taskId, barType, newStartDate, newEndDate));
        }
    }

    public void Dispose()
    {
        try
        {
            JSRuntime.InvokeVoidAsync("ganttScrollSync.dispose");
        }
        catch { }

        dotNetRef?.Dispose();
    }

    private void CalculateTimeline()
    {
        if (Tasks == null || !Tasks.Any())
        {
            TimelineStart = null;
            TimelineEnd = null;
            TotalDays = 0;
            return;
        }

        // 全タスクの最も早い開始日と最も遅い終了日を取得
        var allDates = new List<DateTimeOffset>();

        foreach (var task in Tasks)
        {
            if (task.ScheduledStartDate.HasValue)
                allDates.Add(task.ScheduledStartDate.Value);
            if (task.ScheduledEndDate.HasValue)
                allDates.Add(task.ScheduledEndDate.Value);
            if (task.ActualStartDate.HasValue)
                allDates.Add(task.ActualStartDate.Value);
            if (task.ActualEndDate.HasValue)
                allDates.Add(task.ActualEndDate.Value);
        }

        if (!allDates.Any())
        {
            TimelineStart = null;
            TimelineEnd = null;
            TotalDays = 0;
            return;
        }

        TimelineStart = allDates.Min().Date;
        TimelineEnd = allDates.Max().Date;
        TotalDays = (int)(TimelineEnd.Value - TimelineStart.Value).TotalDays + 1;

        // タイムラインの範囲が実際に変わった場合にのみ基準値を再計算
        // ユーザーが設定したズームレベルは保持される
        if (HasTimelineRangeChanged())
        {
            // 基準値を再計算
            CalculateBaseColumnWidth();
            CalculateBaseRowHeight();

            // ズームレベルは保持（ユーザーが設定した値をそのまま維持）
            // 自動調整は行わない

            // 現在の値を保存
            previousTimelineStart = TimelineStart;
            previousTimelineEnd = TimelineEnd;
            previousTotalDays = TotalDays;
        }
    }

    private bool HasTimelineRangeChanged()
    {
        // 初回の場合は変更ありとみなす
        if (previousTimelineStart == null || previousTimelineEnd == null)
        {
            return true;
        }

        // タイムラインの範囲またはタスク数が変わった場合
        return TimelineStart != previousTimelineStart
            || TimelineEnd != previousTimelineEnd
            || TotalDays != previousTotalDays;
    }

    private string GetGridColumn(DateTimeOffset startDate, DateTimeOffset endDate)
    {
        if (TimelineStart == null) return "1 / 2";

        // グリッドの開始列を計算（1-indexed）
        var startDay = (int)(startDate.Date - TimelineStart.Value).TotalDays + 1;
        var endDay = (int)(endDate.Date - TimelineStart.Value).TotalDays + 2; // 終了日は次の日の始まりまで

        // 範囲外の場合は調整
        startDay = Math.Max(1, Math.Min(startDay, TotalDays));
        endDay = Math.Max(startDay + 1, Math.Min(endDay, TotalDays + 1));

        return $"{startDay} / {endDay}";
    }

    private async Task HandleTaskClick(TaskDto task)
    {
        if (OnTaskClick.HasDelegate)
        {
            await OnTaskClick.InvokeAsync(task);
        }
    }

    private string GetStatusClass(TaskStatus status)
    {
        return status switch
        {
            TaskStatus.Todo => "todo",
            TaskStatus.InProgress => "inprogress",
            TaskStatus.InReview => "inreview",
            TaskStatus.Done => "done",
            _ => "todo"
        };
    }

    private string GetStatusLabel(TaskStatus status)
    {
        return status switch
        {
            TaskStatus.Todo => "未着手",
            TaskStatus.InProgress => "進行中",
            TaskStatus.InReview => "レビュー中",
            TaskStatus.Done => "完了",
            _ => "未着手"
        };
    }

    private List<MonthGroup> GetMonthGroups()
    {
        var groups = new List<MonthGroup>();
        if (TimelineStart == null || TotalDays == 0) return groups;

        var processedDays = 0;
        while (processedDays < TotalDays)
        {
            var currentDate = TimelineStart.Value.AddDays(processedDays);
            var currentMonth = currentDate.Month;
            var currentYear = currentDate.Year;
            var startColumn = processedDays + 1;

            // この月の日数をカウント
            var daysInThisMonth = 0;
            for (int i = processedDays; i < TotalDays; i++)
            {
                var checkDate = TimelineStart.Value.AddDays(i);
                if (checkDate.Month == currentMonth && checkDate.Year == currentYear)
                {
                    daysInThisMonth++;
                }
                else
                {
                    break;
                }
            }

            var endColumn = startColumn + daysInThisMonth;
            groups.Add(new MonthGroup
            {
                Year = currentYear,
                Month = currentMonth,
                StartColumn = startColumn,
                EndColumn = endColumn,
                DayCount = daysInThisMonth
            });

            processedDays += daysInThisMonth;
        }

        return groups;
    }

    private void DetectChanges()
    {
        if (Tasks == null) return;

        var newBarsToAnimate = new HashSet<string>();
        var currentBarStates = new Dictionary<string, BarState>();

        foreach (var task in Tasks)
        {
            // Scheduled Bar
            if (task.ScheduledStartDate.HasValue && task.ScheduledEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "scheduled");
                var currentState = new BarState(task.ScheduledStartDate.Value, task.ScheduledEndDate.Value);
                currentBarStates[key] = currentState;

                if (previousBarStates.TryGetValue(key, out var previousState))
                {
                    // 前回の状態と比較して変更があればアニメーション対象に追加
                    if (!previousState.Equals(currentState))
                    {
                        newBarsToAnimate.Add(key);
                    }
                }
                else
                {
                    // 新規追加されたバーはアニメーション対象
                    newBarsToAnimate.Add(key);
                }
            }

            // Actual Bar
            if (task.ActualStartDate.HasValue && task.ActualEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "actual");
                var currentState = new BarState(task.ActualStartDate.Value, task.ActualEndDate.Value);
                currentBarStates[key] = currentState;

                if (previousBarStates.TryGetValue(key, out var previousState))
                {
                    // 前回の状態と比較して変更があればアニメーション対象に追加
                    if (!previousState.Equals(currentState))
                    {
                        newBarsToAnimate.Add(key);
                    }
                }
                else
                {
                    // 新規追加されたバーはアニメーション対象
                    newBarsToAnimate.Add(key);
                }
            }
        }

        // 削除されたバーを検出（前回存在したが今回存在しないバー）
        // 削除の場合はアニメーションしない（バーが消えるだけ）

        // 状態を更新
        previousBarStates = currentBarStates;
        barsToAnimate = newBarsToAnimate;
    }

    private string GetBarKey(Guid taskId, string barType)
    {
        return $"{taskId}_{barType}";
    }

    private bool ShouldDisplayBar(Guid taskId, string barType)
    {
        var key = GetBarKey(taskId, barType);
        return displayBarStates.ContainsKey(key);
    }

    private BarState? GetDisplayBarState(Guid taskId, string barType)
    {
        var key = GetBarKey(taskId, barType);
        return displayBarStates.TryGetValue(key, out var state) ? state : null;
    }

    private string GetBarAnimationClass(Guid taskId, string barType)
    {
        var key = GetBarKey(taskId, barType);
        if (fadingOutBars.Contains(key))
        {
            return "fading-out";
        }
        if (barsToAnimate.Contains(key))
        {
            return "animating";
        }
        return "";
    }

    private class MonthGroup
    {
        public int Year { get; set; }
        public int Month { get; set; }
        public int StartColumn { get; set; }
        public int EndColumn { get; set; }
        public int DayCount { get; set; }
    }

    private record BarState(DateTimeOffset StartDate, DateTimeOffset EndDate)
    {
        public virtual bool Equals(BarState? other)
        {
            if (ReferenceEquals(this, other)) return true;
            if (other is null) return false;
            // UTC時刻で比較
            return StartDate.UtcDateTime == other.StartDate.UtcDateTime
                && EndDate.UtcDateTime == other.EndDate.UtcDateTime;
        }

        public override int GetHashCode()
        {
            // UTC時刻でハッシュ化
            return HashCode.Combine(StartDate.UtcDateTime, EndDate.UtcDateTime);
        }
    }

    // ========== ズーム機能 ==========

    private void CalculateBaseColumnWidth(bool force = false)
    {
        if (_isBaseColumnWidthCalculated && !force) return;

        if (TotalDays == 0 || availableTimelineWidth == 0)
        {
            baseColumnWidth = 40; // フォールバック
            return;
        }

        baseColumnWidth = availableTimelineWidth / TotalDays;
        _isBaseColumnWidthCalculated = true;
    }

    private void CalculateBaseRowHeight(bool force = false)
    {
        if (_isBaseRowHeightCalculated && !force) return;

        var taskCount = Tasks?.Count ?? 0;
        if (taskCount == 0 || availableTimelineHeight == 0)
        {
            baseRowHeight = 48; // フォールバック
            return;
        }

        baseRowHeight = availableTimelineHeight / taskCount;
        _isBaseRowHeightCalculated = true;
    }

    private string GetGridTemplateColumns()
    {
        var cellWidth = GetActualCellWidth();
        return $"repeat({TotalDays}, {cellWidth}px)";
    }

    private double GetActualCellWidth()
    {
        var width = baseColumnWidth * horizontalZoomScale;
        // 最小8px、最大120pxに制限
        return Math.Max(8, Math.Min(120, width));
    }

    private double GetActualRowHeight()
    {
        var height = baseRowHeight * verticalZoomScale;
        // 最小24px、最大60pxに制限
        return Math.Max(24, Math.Min(60, height));
    }

    private string GetRowHeightStyle()
    {
        var rowHeight = GetActualRowHeight();
        return $"height: {rowHeight}px;";
    }

    private double GetBarHeight()
    {
        var rowHeight = GetActualRowHeight();
        // バーの高さを行の高さの35%にする
        var barHeight = rowHeight * 0.35;
        // 最小6px、最大16pxに制限
        return Math.Max(6, Math.Min(16, barHeight));
    }

    private double GetBarGap()
    {
        var rowHeight = GetActualRowHeight();
        // ギャップを行の高さの2%にする
        var gap = rowHeight * 0.02;
        // 最小0px、最大4pxに制限
        return Math.Max(0, Math.Min(4, gap));
    }

    private string GetStatusBadgeStyle()
    {
        var rowHeight = GetActualRowHeight();
        // フォントサイズを行の高さに応じて調整
        var fontSize = rowHeight * 0.25; // 行の高さの25%
        fontSize = Math.Max(0.6, Math.Min(0.75, fontSize)); // 0.6rem〜0.75rem

        // パディングを行の高さに応じて調整
        var paddingVertical = rowHeight * 0.02; // 行の高さの2%
        paddingVertical = Math.Max(1, Math.Min(3, paddingVertical)); // 1px〜3px

        var paddingHorizontal = rowHeight * 0.12; // 行の高さの12%
        paddingHorizontal = Math.Max(4, Math.Min(8, paddingHorizontal)); // 4px〜8px

        return $"font-size: {fontSize}rem; padding: {paddingVertical}px {paddingHorizontal}px;";
    }

    private string GetBarMarginStyle(string barType)
    {
        var rowHeight = GetActualRowHeight();
        var barHeight = GetBarHeight();
        var gap = GetBarGap();
        var verticalMargin = (rowHeight - barHeight - barHeight - gap) / 2;

        if (barType == "scheduled")
        {
            // 上側のバー
            return $"height: {barHeight}px; margin-top: {verticalMargin}px; margin-bottom: {gap}px;";
        }
        else // actual
        {
            // 下側のバー
            return $"height: {barHeight}px; margin-top: {gap}px; margin-bottom: {verticalMargin}px;";
        }
    }

    // 横方向ズーム
    private bool CanZoomInHorizontal => horizontalZoomLevelIndex < ZoomLevels.Length - 1;
    private bool CanZoomOutHorizontal => horizontalZoomLevelIndex > 0;

    private async Task ZoomInHorizontal()
    {
        if (CanZoomInHorizontal)
        {
            horizontalZoomLevelIndex++;
            await ApplyHorizontalZoomLevel();
        }
    }

    private async Task ZoomOutHorizontal()
    {
        if (CanZoomOutHorizontal)
        {
            horizontalZoomLevelIndex--;
            await ApplyHorizontalZoomLevel();
        }
    }

    private async Task ApplyHorizontalZoomLevel()
    {
        horizontalZoomScale = ZoomLevels[horizontalZoomLevelIndex];

        // ローカルストレージに保存
        await SaveZoomLevelsToStorage();

        if (OnZoomChanged.HasDelegate)
        {
            await OnZoomChanged.InvokeAsync(horizontalZoomScale);
        }

        StateHasChanged();
    }

    // 縦方向ズーム
    private bool CanZoomInVertical => verticalZoomLevelIndex < ZoomLevels.Length - 1;
    private bool CanZoomOutVertical => verticalZoomLevelIndex > 0;

    private async Task ZoomInVertical()
    {
        if (CanZoomInVertical)
        {
            verticalZoomLevelIndex++;
            await ApplyVerticalZoomLevel();
        }
    }

    private async Task ZoomOutVertical()
    {
        if (CanZoomOutVertical)
        {
            verticalZoomLevelIndex--;
            await ApplyVerticalZoomLevel();
        }
    }

    private async Task ApplyVerticalZoomLevel()
    {
        verticalZoomScale = ZoomLevels[verticalZoomLevelIndex];

        // ローカルストレージに保存
        await SaveZoomLevelsToStorage();

        StateHasChanged();
    }

    // 全体表示
    private async Task FitToScreen()
    {
        // 強制的に再計算して画面に合わせる
        CalculateBaseColumnWidth(force: true);
        CalculateBaseRowHeight(force: true);
        
        horizontalZoomLevelIndex = 0; // 100%（全体表示）にリセット
        verticalZoomLevelIndex = 0; // 100%（全体表示）にリセット
        await ApplyHorizontalZoomLevel();
        await ApplyVerticalZoomLevel();
    }

    private async Task LoadZoomLevelsFromStorage()
    {
        try
        {
            // 横方向ズームを復元
            var hZoom = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "gantt_hZoom");
            if (hZoom != null && int.TryParse(hZoom, out var hZoomIndex))
            {
                if (hZoomIndex >= 0 && hZoomIndex < ZoomLevels.Length)
                {
                    horizontalZoomLevelIndex = hZoomIndex;
                    horizontalZoomScale = ZoomLevels[hZoomIndex];
                }
            }

            // 縦方向ズームを復元
            var vZoom = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "gantt_vZoom");
            if (vZoom != null && int.TryParse(vZoom, out var vZoomIndex))
            {
                if (vZoomIndex >= 0 && vZoomIndex < ZoomLevels.Length)
                {
                    verticalZoomLevelIndex = vZoomIndex;
                    verticalZoomScale = ZoomLevels[vZoomIndex];
                }
            }
        }
        catch (Exception ex)
        {
            // ストレージ読み取りエラーは無視（デフォルト値を使用）
            Console.Error.WriteLine($"ローカルストレージからズームレベルを読み取れませんでした: {ex.Message}");
        }
    }

    private async Task SaveZoomLevelsToStorage()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "gantt_hZoom", horizontalZoomLevelIndex.ToString());
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "gantt_vZoom", verticalZoomLevelIndex.ToString());
        }
        catch (Exception ex)
        {
            // ストレージ保存エラーは無視（機能には影響しない）
            Console.Error.WriteLine($"ローカルストレージにズームレベルを保存できませんでした: {ex.Message}");
        }
    }

    private bool ShouldDisplayDateLabel(int dayIndex)
    {
        if (TimelineStart == null) return false;

        var cellWidth = GetActualCellWidth();
        var date = TimelineStart.Value.AddDays(dayIndex);

        // セル幅に応じて表示頻度を調整
        if (cellWidth >= 30)
        {
            // 広い: すべての日付を表示
            return true;
        }
        else if (cellWidth >= 25)
        {
            // やや広い: 2日おき + 月初を表示
            return date.Day == 1 || dayIndex % 2 == 0;
        }
        else if (cellWidth >= 18)
        {
            // 中程度: 3日おき + 月初を表示
            return date.Day == 1 || dayIndex % 3 == 0;
        }
        else if (cellWidth >= 12)
        {
            // やや狭い: 5日おき + 月初を表示
            return date.Day == 1 || date.Day % 5 == 0;
        }
        else
        {
            // 非常に狭い: 10日おき + 月初を表示
            return date.Day == 1 || date.Day % 10 == 0;
        }
    }
}
