@using RewindPM.Application.Read.DTOs
@using TaskStatus = RewindPM.Domain.ValueObjects.TaskStatus
@using Microsoft.JSInterop
@using RewindPM.Web.Components.Shared
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="gantt-chart @(IsReadOnly ? "readonly-mode" : "")">
    @if (Tasks == null || !Tasks.Any())
    {
        <div class="gantt-empty">
            <p>タスクがありません</p>
        </div>
    }
    else if (TimelineStart == null || TimelineEnd == null)
    {
        <div class="gantt-empty">
            <p>予定期間が設定されたタスクがありません</p>
        </div>
    }
    else
    {
        <div class="gantt-scroll-container">
            @* Header Row *@
            <div class="gantt-row gantt-header-row">
                <div class="gantt-cell gantt-sticky-left gantt-header-corner">タスク名</div>
                <div class="gantt-timeline-area">
                    @* Month Row *@
                    <div class="gantt-timeline-subrow">
                        <div class="gantt-timeline-grid" style="grid-template-columns: repeat(@TotalDays, minmax(40px, 1fr));">
                            @foreach (var monthGroup in GetMonthGroups())
                            {
                                <div class="gantt-month-cell" style="grid-column: @monthGroup.StartColumn / @monthGroup.EndColumn;">
                                    @monthGroup.Year/@monthGroup.Month
                                </div>
                            }
                        </div>
                    </div>
                    @* Date Row *@
                    <div class="gantt-timeline-subrow">
                        <div class="gantt-timeline-grid" style="grid-template-columns: repeat(@TotalDays, minmax(40px, 1fr));">
                            @for (int i = 0; i < TotalDays; i++)
                            {
                                var date = TimelineStart.Value.AddDays(i);
                                <div class="gantt-date-cell">
                                    <div class="gantt-date-label">@date.Day</div>
                                </div>
                            }
                        </div>
                    </div>
                </div>
            </div>

            @* Task Rows *@
            @foreach (var (task, index) in Tasks.Select((t, i) => (t, i)))
            {
                <div class="gantt-row gantt-task-row">
                    <div class="gantt-cell gantt-sticky-left gantt-task-name-cell" title="@task.Title" @onclick="() => HandleTaskClick(task)">
                        <span class="gantt-task-title">@task.Title</span>
                        <span class="gantt-task-status gantt-status-@GetStatusClass(task.Status)">
                            @GetStatusLabel(task.Status)
                        </span>
                    </div>
                    <div class="gantt-timeline-area">
                        <div class="gantt-timeline-grid" style="grid-template-columns: repeat(@TotalDays, minmax(40px, 1fr));">
                            @* Scheduled Bar *@
                            @if (ShouldDisplayBar(task.Id, "scheduled"))
                            {
                                var barState = GetDisplayBarState(task.Id, "scheduled");
                                if (barState != null)
                                {
                                    var gridColumn = GetGridColumn(barState.StartDate, barState.EndDate);
                                    var animationClass = GetBarAnimationClass(task.Id, "scheduled");
                                    <div class="gantt-bar gantt-bar-scheduled @animationClass"
                                         style="grid-column: @gridColumn;"
                                         title="予定: @barState.StartDate.ToString("yyyy/MM/dd") - @barState.EndDate.ToString("yyyy/MM/dd")"
                                         data-task-id="@task.Id"
                                         data-bar-type="scheduled">
                                        @if (!IsReadOnly && string.IsNullOrEmpty(animationClass))
                                        {
                                            <div class="gantt-resize-handle gantt-resize-handle-left"></div>
                                            <div class="gantt-resize-handle gantt-resize-handle-right"></div>
                                        }
                                    </div>
                                }
                            }

                            @* Actual Bar *@
                            @if (ShouldDisplayBar(task.Id, "actual"))
                            {
                                var barState = GetDisplayBarState(task.Id, "actual");
                                if (barState != null)
                                {
                                    var gridColumn = GetGridColumn(barState.StartDate, barState.EndDate);
                                    var animationClass = GetBarAnimationClass(task.Id, "actual");
                                    <div class="gantt-bar gantt-bar-actual @animationClass"
                                         style="grid-column: @gridColumn;"
                                         title="実績: @barState.StartDate.ToString("yyyy/MM/dd") - @barState.EndDate.ToString("yyyy/MM/dd")"
                                         data-task-id="@task.Id"
                                         data-bar-type="actual">
                                        @if (!IsReadOnly && string.IsNullOrEmpty(animationClass))
                                        {
                                            <div class="gantt-resize-handle gantt-resize-handle-left"></div>
                                            <div class="gantt-resize-handle gantt-resize-handle-right"></div>
                                        }
                                    </div>
                                }
                            }
                        </div>
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter]
    public List<TaskDto> Tasks { get; set; } = new();

    [Parameter]
    public EventCallback<TaskDto> OnTaskClick { get; set; }

    [Parameter]
    public EventCallback<(Guid taskId, string barType, DateTimeOffset newStartDate, DateTimeOffset newEndDate)> OnBarResize { get; set; }

    [Parameter]
    public DateTimeOffset? ViewDate { get; set; }

    [Parameter]
    public bool IsReadOnly { get; set; } = false;

    private DateTime? TimelineStart { get; set; }
    private DateTime? TimelineEnd { get; set; }
    private int TotalDays { get; set; }

    private DotNetObjectReference<GanttChart>? dotNetRef;
    private bool scriptsInitialized = false;

    // 前回のバー状態を保持（アニメーション判定用）
    private Dictionary<string, BarState> previousBarStates = new();
    private HashSet<string> barsToAnimate = new();
    private readonly HashSet<string> fadingOutBars = new();
    private Dictionary<string, BarState> displayBarStates = new();

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();

        if (IsInitialLoad())
        {
            InitializeBarStates();
            InitializeDisplayBarStates();
        }
        else
        {
            await HandleBarsChanged();
        }

        CalculateTimeline();
    }

    private bool IsInitialLoad() => previousBarStates.Count == 0;

    private void InitializeBarStates()
    {
        if (Tasks == null) return;

        foreach (var task in Tasks)
        {
            if (task.ScheduledStartDate.HasValue && task.ScheduledEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "scheduled");
                previousBarStates[key] = new BarState(task.ScheduledStartDate.Value, task.ScheduledEndDate.Value);
            }

            if (task.ActualStartDate.HasValue && task.ActualEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "actual");
                previousBarStates[key] = new BarState(task.ActualStartDate.Value, task.ActualEndDate.Value);
            }
        }
    }

    private void InitializeDisplayBarStates()
    {
        displayBarStates = previousBarStates.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
    }

    private async Task HandleBarsChanged()
    {
        var currentBarStates = GetCurrentBarStates();
        var removedBars = GetRemovedBars(currentBarStates);

        if (removedBars.Any())
        {
            await AnimateBarRemoval(removedBars);
        }
        else
        {
            DetectChanges();
            UpdateDisplayBarStates();
        }

        previousBarStates = currentBarStates;
    }

    private Dictionary<string, BarState> GetCurrentBarStates()
    {
        var currentBarStates = new Dictionary<string, BarState>();
        if (Tasks == null) return currentBarStates;

        foreach (var task in Tasks)
        {
            if (task.ScheduledStartDate.HasValue && task.ScheduledEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "scheduled");
                currentBarStates[key] = new BarState(task.ScheduledStartDate.Value, task.ScheduledEndDate.Value);
            }

            if (task.ActualStartDate.HasValue && task.ActualEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "actual");
                currentBarStates[key] = new BarState(task.ActualStartDate.Value, task.ActualEndDate.Value);
            }
        }

        return currentBarStates;
    }

    private List<string> GetRemovedBars(Dictionary<string, BarState> currentBarStates)
    {
        return previousBarStates.Keys
            .Where(key => !currentBarStates.ContainsKey(key))
            .ToList();
    }

    private async Task AnimateBarRemoval(List<string> removedBars)
    {
        // フェードアウト対象をマーク
        foreach (var barKey in removedBars)
        {
            fadingOutBars.Add(barKey);
        }

        // 表示バーは前回の状態を維持（削除されるバーも表示し続ける）
        displayBarStates = previousBarStates.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

        // 変更検出も実行（他のバーの変更を検出）
        DetectChanges();

        StateHasChanged();

        // アニメーション期間待機
        await Task.Delay(AnimationConstants.FadeOutDurationMs);

        // フェードアウト完了後、実際に削除
        fadingOutBars.Clear();
        UpdateDisplayBarStates();
    }

    private void UpdateDisplayBarStates()
    {
        displayBarStates = GetCurrentBarStates();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || !scriptsInitialized)
        {
            try
            {
                dotNetRef = DotNetObjectReference.Create(this);
                // Only initialize resize handles and pass dotnet ref for callbacks
                await JSRuntime.InvokeVoidAsync("ganttScrollSync.initialize", dotNetRef);
                scriptsInitialized = true;
            }
            catch (Exception ex)
            {
                // JavaScript初期化エラーをログに記録
                Console.Error.WriteLine($"ガントチャートの初期化エラー: {ex.Message}");
            }
        }
        else
        {
            try
            {
                // 再レンダリング後にリサイズハンドルを再初期化
                await JSRuntime.InvokeVoidAsync("ganttScrollSync.reinitializeResizeHandles");
            }
            catch (Exception ex)
            {
                // JavaScript再初期化エラーをログに記録
                Console.Error.WriteLine($"リサイズハンドルの再初期化エラー: {ex.Message}");
            }
        }
    }

    [JSInvokable]
    public async Task OnBarResized(string taskIdStr, string barType, int startDayIndex, int endDayIndex)
    {
        if (TimelineStart == null) return;

        if (!Guid.TryParse(taskIdStr, out var taskId)) return;

        // インデックスから日付を計算（UTC offsetで統一）
        var newStartDate = new DateTimeOffset(TimelineStart.Value.AddDays(startDayIndex), TimeSpan.Zero);
        var newEndDate = new DateTimeOffset(TimelineStart.Value.AddDays(endDayIndex), TimeSpan.Zero);

        // コールバックを呼び出し
        if (OnBarResize.HasDelegate)
        {
            await OnBarResize.InvokeAsync((taskId, barType, newStartDate, newEndDate));
        }
    }

    public void Dispose()
    {
        try
        {
            JSRuntime.InvokeVoidAsync("ganttScrollSync.dispose");
        }
        catch { }

        dotNetRef?.Dispose();
    }

    private void CalculateTimeline()
    {
        if (Tasks == null || !Tasks.Any())
        {
            TimelineStart = null;
            TimelineEnd = null;
            TotalDays = 0;
            return;
        }

        // 全タスクの最も早い開始日と最も遅い終了日を取得
        var allDates = new List<DateTimeOffset>();

        foreach (var task in Tasks)
        {
            if (task.ScheduledStartDate.HasValue)
                allDates.Add(task.ScheduledStartDate.Value);
            if (task.ScheduledEndDate.HasValue)
                allDates.Add(task.ScheduledEndDate.Value);
            if (task.ActualStartDate.HasValue)
                allDates.Add(task.ActualStartDate.Value);
            if (task.ActualEndDate.HasValue)
                allDates.Add(task.ActualEndDate.Value);
        }

        if (!allDates.Any())
        {
            TimelineStart = null;
            TimelineEnd = null;
            TotalDays = 0;
            return;
        }

        TimelineStart = allDates.Min().Date;
        TimelineEnd = allDates.Max().Date;
        TotalDays = (int)(TimelineEnd.Value - TimelineStart.Value).TotalDays + 1;
    }

    private string GetGridColumn(DateTimeOffset startDate, DateTimeOffset endDate)
    {
        if (TimelineStart == null) return "1 / 2";

        // グリッドの開始列を計算（1-indexed）
        var startDay = (int)(startDate.Date - TimelineStart.Value).TotalDays + 1;
        var endDay = (int)(endDate.Date - TimelineStart.Value).TotalDays + 2; // 終了日は次の日の始まりまで

        // 範囲外の場合は調整
        startDay = Math.Max(1, Math.Min(startDay, TotalDays));
        endDay = Math.Max(startDay + 1, Math.Min(endDay, TotalDays + 1));

        return $"{startDay} / {endDay}";
    }

    private async Task HandleTaskClick(TaskDto task)
    {
        if (OnTaskClick.HasDelegate)
        {
            await OnTaskClick.InvokeAsync(task);
        }
    }

    private string GetStatusClass(TaskStatus status)
    {
        return status switch
        {
            TaskStatus.Todo => "todo",
            TaskStatus.InProgress => "inprogress",
            TaskStatus.InReview => "inreview",
            TaskStatus.Done => "done",
            _ => "todo"
        };
    }

    private string GetStatusLabel(TaskStatus status)
    {
        return status switch
        {
            TaskStatus.Todo => "TODO",
            TaskStatus.InProgress => "進行中",
            TaskStatus.InReview => "レビュー中",
            TaskStatus.Done => "完了",
            _ => "TODO"
        };
    }

    private List<MonthGroup> GetMonthGroups()
    {
        var groups = new List<MonthGroup>();
        if (TimelineStart == null || TotalDays == 0) return groups;

        var processedDays = 0;
        while (processedDays < TotalDays)
        {
            var currentDate = TimelineStart.Value.AddDays(processedDays);
            var currentMonth = currentDate.Month;
            var currentYear = currentDate.Year;
            var startColumn = processedDays + 1;

            // この月の日数をカウント
            var daysInThisMonth = 0;
            for (int i = processedDays; i < TotalDays; i++)
            {
                var checkDate = TimelineStart.Value.AddDays(i);
                if (checkDate.Month == currentMonth && checkDate.Year == currentYear)
                {
                    daysInThisMonth++;
                }
                else
                {
                    break;
                }
            }

            var endColumn = startColumn + daysInThisMonth;
            groups.Add(new MonthGroup
            {
                Year = currentYear,
                Month = currentMonth,
                StartColumn = startColumn,
                EndColumn = endColumn,
                DayCount = daysInThisMonth
            });

            processedDays += daysInThisMonth;
        }

        return groups;
    }

    private void DetectChanges()
    {
        if (Tasks == null) return;

        var newBarsToAnimate = new HashSet<string>();
        var currentBarStates = new Dictionary<string, BarState>();

        foreach (var task in Tasks)
        {
            // Scheduled Bar
            if (task.ScheduledStartDate.HasValue && task.ScheduledEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "scheduled");
                var currentState = new BarState(task.ScheduledStartDate.Value, task.ScheduledEndDate.Value);
                currentBarStates[key] = currentState;

                if (previousBarStates.TryGetValue(key, out var previousState))
                {
                    // 前回の状態と比較して変更があればアニメーション対象に追加
                    if (!previousState.Equals(currentState))
                    {
                        newBarsToAnimate.Add(key);
                    }
                }
                else
                {
                    // 新規追加されたバーはアニメーション対象
                    newBarsToAnimate.Add(key);
                }
            }

            // Actual Bar
            if (task.ActualStartDate.HasValue && task.ActualEndDate.HasValue)
            {
                var key = GetBarKey(task.Id, "actual");
                var currentState = new BarState(task.ActualStartDate.Value, task.ActualEndDate.Value);
                currentBarStates[key] = currentState;

                if (previousBarStates.TryGetValue(key, out var previousState))
                {
                    // 前回の状態と比較して変更があればアニメーション対象に追加
                    if (!previousState.Equals(currentState))
                    {
                        newBarsToAnimate.Add(key);
                    }
                }
                else
                {
                    // 新規追加されたバーはアニメーション対象
                    newBarsToAnimate.Add(key);
                }
            }
        }

        // 削除されたバーを検出（前回存在したが今回存在しないバー）
        // 削除の場合はアニメーションしない（バーが消えるだけ）

        // 状態を更新
        previousBarStates = currentBarStates;
        barsToAnimate = newBarsToAnimate;
    }

    private string GetBarKey(Guid taskId, string barType)
    {
        return $"{taskId}_{barType}";
    }

    private bool ShouldDisplayBar(Guid taskId, string barType)
    {
        var key = GetBarKey(taskId, barType);
        return displayBarStates.ContainsKey(key);
    }

    private BarState? GetDisplayBarState(Guid taskId, string barType)
    {
        var key = GetBarKey(taskId, barType);
        return displayBarStates.TryGetValue(key, out var state) ? state : null;
    }

    private string GetBarAnimationClass(Guid taskId, string barType)
    {
        var key = GetBarKey(taskId, barType);
        if (fadingOutBars.Contains(key))
        {
            return "fading-out";
        }
        if (barsToAnimate.Contains(key))
        {
            return "animating";
        }
        return "";
    }

    private class MonthGroup
    {
        public int Year { get; set; }
        public int Month { get; set; }
        public int StartColumn { get; set; }
        public int EndColumn { get; set; }
        public int DayCount { get; set; }
    }

    private record BarState(DateTimeOffset StartDate, DateTimeOffset EndDate)
    {
        public virtual bool Equals(BarState? other)
        {
            if (ReferenceEquals(this, other)) return true;
            if (other is null) return false;
            // UTC時刻で比較
            return StartDate.UtcDateTime == other.StartDate.UtcDateTime
                && EndDate.UtcDateTime == other.EndDate.UtcDateTime;
        }

        public override int GetHashCode()
        {
            // UTC時刻でハッシュ化
            return HashCode.Combine(StartDate.UtcDateTime, EndDate.UtcDateTime);
        }
    }
}
